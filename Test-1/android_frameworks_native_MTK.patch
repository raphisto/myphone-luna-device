From fa6add874c68558b2dfb16a6534c4081ff1ae833 Mon Sep 17 00:00:00 2001
From: adi766 <adityakumarteli7846@gmail.com>
Date: Sat, 23 Sep 2017 08:57:48 +0000
Subject: [PATCH] MediaTek: Fix Graphics

Signed-off-by: teja98 <tejachaitu96@gmail.com>
---
 include/gui/BufferQueueCore.h       |   4 --
 include/gui/IProducerListener.h     |   3 -
 include/ui/Fence.h                  |  29 +-------
 include/ui/mediatek/GuiExtMonitor.h | 133 ++++++++++++++++++++++++++++++++++++
 include/ui/mediatek/IDumpTunnel.h   |  49 +++++++++++++
 include/ui/mediatek/RefBaseDump.h   |  34 +++++++++
 libs/gui/Android.mk                 |   1 -
 libs/gui/BufferQueueCore.cpp        |   1 -
 libs/gui/BufferQueueProducer.cpp    |   8 +--
 libs/gui/ConsumerBase.cpp           |  17 +----
 libs/gui/GLConsumer.cpp             |  11 +--
 libs/gui/IGraphicBufferProducer.cpp |   7 --
 libs/gui/IProducerListener.cpp      |  26 -------
 libs/gui/Surface.cpp                |   6 --
 libs/ui/Android.mk                  |   7 +-
 libs/ui/Fence.cpp                   |  20 +++---
 libs/ui/mediatek/Fence.cpp          |  58 ++++++++++++++++
 libs/ui/mediatek/IDumpTunnel.cpp    | 116 +++++++++++++++++++++++++++++++
 libs/ui/mediatek/RefBaseDump.cpp    |  70 +++++++++++++++++++
 opengl/libs/EGL/Loader.cpp          |  85 ++---------------------
 opengl/libs/EGL/Loader.h            |   5 --
 opengl/libs/EGL/eglApi.cpp          |   6 ++
 vulkan/libvulkan/driver.cpp         |  73 ++------------------
 23 files changed, 501 insertions(+), 268 deletions(-)
 create mode 100644 include/ui/mediatek/GuiExtMonitor.h
 create mode 100644 include/ui/mediatek/IDumpTunnel.h
 create mode 100644 include/ui/mediatek/RefBaseDump.h
 create mode 100644 libs/ui/mediatek/Fence.cpp
 create mode 100644 libs/ui/mediatek/IDumpTunnel.cpp
 create mode 100644 libs/ui/mediatek/RefBaseDump.cpp

diff --git a/include/gui/BufferQueueCore.h b/include/gui/BufferQueueCore.h
index 4e54ddb29..14b7e0448 100644
--- a/include/gui/BufferQueueCore.h
+++ b/include/gui/BufferQueueCore.h
@@ -185,10 +185,6 @@ class BufferQueueCore : public virtual RefBase {
     // PID of the process which last successfully called connect(...)
     pid_t mConnectedPid;
 
-    // mLinkedToDeath is used to set a binder death notification on
-    // the producer.
-    sp<IProducerListener> mLinkedToDeath;
-
     // mConnectedProducerListener is used to handle the onBufferReleased
     // notification.
     sp<IProducerListener> mConnectedProducerListener;
diff --git a/include/gui/IProducerListener.h b/include/gui/IProducerListener.h
index b7826c677..3848a6c85 100644
--- a/include/gui/IProducerListener.h
+++ b/include/gui/IProducerListener.h
@@ -41,7 +41,6 @@ class ProducerListener : public virtual RefBase
     // This is called without any lock held and can be called concurrently by
     // multiple threads.
     virtual void onBufferReleased() = 0; // Asynchronous
-    virtual bool needsReleaseNotify() = 0;
 };
 
 class IProducerListener : public ProducerListener, public IInterface
@@ -55,14 +54,12 @@ class BnProducerListener : public BnInterface<IProducerListener>
 public:
     virtual status_t onTransact(uint32_t code, const Parcel& data,
             Parcel* reply, uint32_t flags = 0);
-    virtual bool needsReleaseNotify();
 };
 
 class DummyProducerListener : public BnProducerListener
 {
 public:
     virtual void onBufferReleased() {}
-    virtual bool needsReleaseNotify() { return false; }
 };
 
 } // namespace android
diff --git a/include/ui/Fence.h b/include/ui/Fence.h
index 48a7aa3c5..c26d49561 100644
--- a/include/ui/Fence.h
+++ b/include/ui/Fence.h
@@ -27,8 +27,6 @@
 #include <utils/String8.h>
 #include <utils/Timers.h>
 
-#include <experimental/optional>
-
 struct ANativeWindowBuffer;
 
 namespace android {
@@ -81,9 +79,6 @@ class Fence
     // becomes signaled when both f1 and f2 are signaled (even if f1 or f2 is
     // destroyed before it becomes signaled).  The name argument specifies the
     // human-readable name to associated with the new Fence object.
-    static sp<Fence> merge(const char* name, const sp<Fence>& f1,
-            const sp<Fence>& f2);
-
     static sp<Fence> merge(const String8& name, const sp<Fence>& f1,
             const sp<Fence>& f2);
 
@@ -98,27 +93,6 @@ class Fence
     // occurs then -1 is returned.
     nsecs_t getSignalTime() const;
 
-#if __cplusplus > 201103L
-    // hasSignaled returns whether the fence has signaled yet. Prefer this to
-    // getSignalTime() or wait() if all you care about is whether the fence has
-    // signaled. Returns an optional bool, which will have a value if there was
-    // no error.
-    inline std::experimental::optional<bool> hasSignaled() {
-        // The sync_wait call underlying wait() has been measured to be
-        // significantly faster than the sync_fence_info call underlying
-        // getSignalTime(), which might otherwise appear to be the more obvious
-        // way to check whether a fence has signaled.
-        switch (wait(0)) {
-            case NO_ERROR:
-                return true;
-            case -ETIME:
-                return false;
-            default:
-                return {};
-        }
-    }
-#endif
-
     // Flattenable interface
     size_t getFlattenedSize() const;
     size_t getFdCount() const;
@@ -136,6 +110,9 @@ class Fence
     const Fence& operator = (const Fence& rhs) const;
 
     int mFenceFd;
+    
+private:
+    void dump(int fd);
 };
 
 }; // namespace android
diff --git a/include/ui/mediatek/GuiExtMonitor.h b/include/ui/mediatek/GuiExtMonitor.h
new file mode 100644
index 000000000..614d1c4f4
--- /dev/null
+++ b/include/ui/mediatek/GuiExtMonitor.h
@@ -0,0 +1,133 @@
+#ifndef __GUIEXT_MONITOR_H__
+#define __GUIEXT_MONITOR_H__
+
+
+#include <utils/String8.h>
+#include <utils/Singleton.h>
+#include <utils/KeyedVector.h>
+
+#include <ui/mediatek/IDumpTunnel.h>
+
+
+namespace android {
+
+template <typename TYPE, typename ITEM>
+class GuiExtMonitor : public Singleton<TYPE>
+{
+public:
+    GuiExtMonitor();
+    virtual ~GuiExtMonitor();
+
+    virtual status_t monitor(ITEM item);
+    virtual status_t unmonitor(ITEM item);
+
+    virtual status_t dump(String8& result, const char* prefix);
+
+protected:
+    status_t getProcessName();
+    virtual String8 getKeyName() const;
+
+protected:
+    bool mIsRegistered;
+    String8 mProcessName;
+    mutable Mutex mLock;
+    sp<BnDumpTunnel> mDumpTunnel;
+    KeyedVector<ITEM, int> mItemList;
+};
+
+
+//--------------------------------------------------------------------------------------------------
+
+template <typename TYPE, typename ITEM>
+GuiExtMonitor<TYPE, ITEM>::GuiExtMonitor()
+    : mIsRegistered(false) {
+    getProcessName();
+}
+
+
+template <typename TYPE, typename ITEM>
+GuiExtMonitor<TYPE, ITEM>::~GuiExtMonitor() {
+    Mutex::Autolock _l(mLock);
+
+    if (mIsRegistered) {
+        DumpTunnelHelper::getInstance().unregDump(getKeyName());
+        mIsRegistered = false;
+    }
+}
+
+
+template <typename TYPE, typename ITEM>
+status_t GuiExtMonitor<TYPE, ITEM>::monitor(ITEM item) {
+    Mutex::Autolock _l(mLock);
+
+    mItemList.add(item, 0);
+    if (!mIsRegistered)
+    {
+
+        class MonitorTunnel : public BnDumpTunnel {
+        public:
+            MonitorTunnel(GuiExtMonitor<TYPE, ITEM>* pMonitor)
+                : mMonitor(pMonitor) {}
+            virtual ~MonitorTunnel() {}
+
+            // IDumpTunnel interface
+            virtual status_t kickDump(String8& result, const char* prefix) {
+                return mMonitor->dump(result, prefix);
+            }
+
+        private:
+            GuiExtMonitor<TYPE, ITEM>* mMonitor;
+        };
+
+        mDumpTunnel = new MonitorTunnel(this);
+        if (DumpTunnelHelper::getInstance().regDump(mDumpTunnel, getKeyName())) {
+            mIsRegistered = true;
+        }
+    }
+    return NO_ERROR;
+}
+
+
+template <typename TYPE, typename ITEM>
+status_t GuiExtMonitor<TYPE, ITEM>::unmonitor(ITEM item) {
+    Mutex::Autolock _l(mLock);
+
+    mItemList.removeItem(item);
+    return NO_ERROR;
+}
+
+
+template <typename TYPE, typename ITEM>
+status_t GuiExtMonitor<TYPE, ITEM>::dump(String8& /*result*/, const char* /*prefix*/) {
+    return NO_ERROR;
+}
+
+
+template <typename TYPE, typename ITEM>
+status_t GuiExtMonitor<TYPE, ITEM>::getProcessName() {
+    int pid = getpid();
+    FILE *fp = fopen(String8::format("/proc/%d/cmdline", pid), "r");
+    if (NULL != fp) {
+        const size_t size = 64;
+        char proc_name[size];
+        fgets(proc_name, size, fp);
+        fclose(fp);
+        mProcessName = proc_name;
+    } else {
+        mProcessName = "unknownProcess";
+    }
+    return NO_ERROR;
+}
+
+
+#define IMPLEMENT_META_GUIEXTMONITOR(TYPE, ITEM, NAME)                                  \
+    ANDROID_SINGLETON_STATIC_INSTANCE(TYPE);                                            \
+    template <>                                                                         \
+    String8 GuiExtMonitor<TYPE, ITEM>::getKeyName() const {                             \
+        return String8::format("%s-[%d:%s]", NAME, getpid(), mProcessName.string());    \
+    }
+
+
+}; // namespace android
+
+#endif
\ No newline at end of file
diff --git a/include/ui/mediatek/IDumpTunnel.h b/include/ui/mediatek/IDumpTunnel.h
new file mode 100644
index 000000000..8f9b6636b
--- /dev/null
+++ b/include/ui/mediatek/IDumpTunnel.h
@@ -0,0 +1,49 @@
+#ifndef ANDROID_GUI_IDUMPTUNNEL_H
+#define ANDROID_GUI_IDUMPTUNNEL_H
+
+#include <binder/IInterface.h>
+#include <utils/Singleton.h>
+
+namespace android
+{
+
+class IDumpTunnel : public IInterface {
+protected:
+    enum {
+        DUMPTUNNEL_DUMP = IBinder::FIRST_CALL_TRANSACTION
+    };
+
+public:
+    DECLARE_META_INTERFACE(DumpTunnel);
+
+    virtual status_t kickDump(String8& /*result*/, const char* /*prefix*/) = 0;
+};
+
+class BnDumpTunnel : public BnInterface<IDumpTunnel>
+{
+    virtual status_t onTransact(uint32_t code,
+                                const Parcel& data,
+                                Parcel* reply,
+                                uint32_t flags = 0);
+};
+
+// helper class for libgui_ext dynamic linking
+class DumpTunnelHelper : public Singleton<DumpTunnelHelper> {
+    void* mSoHandle;
+    bool (*mRegDumpPtr)(const sp<IDumpTunnel>&, const String8&);
+    bool (*mUnregDumpPtr)(const String8&);
+
+public:
+    DumpTunnelHelper();
+    virtual ~DumpTunnelHelper();
+
+    // register tunnel into guiext-server with a given key name
+    // and need to unregister it back
+    // in general usage, need to use identical key name for reg/unreg pair
+    bool regDump(const sp<IDumpTunnel>& tunnel, const String8& key);
+    bool unregDump(const String8& key);
+};
+
+
+};
+#endif
diff --git a/include/ui/mediatek/RefBaseDump.h b/include/ui/mediatek/RefBaseDump.h
new file mode 100644
index 000000000..1ac82187c
--- /dev/null
+++ b/include/ui/mediatek/RefBaseDump.h
@@ -0,0 +1,34 @@
+#ifndef ANDROID_REFBASE_DUMP_H__
+#define ANDROID_REFBASE_DUMP_H__
+
+#include <utils/String8.h>
+#include <ui/mediatek/GuiExtMonitor.h>
+
+namespace android {
+
+//-------------------------------------------------------------------------
+// RefBaseMonitor
+//-------------------------------------------------------------------------
+class RefBaseMonitor : public GuiExtMonitor<RefBaseMonitor, RefBase*> {
+public:
+    RefBaseMonitor();
+    ~RefBaseMonitor() {}
+
+    // add refbase to the monitored list
+    status_t monitor(RefBase* pRb);
+
+    // dump all elements in the monitored list and call printRefs if mIsTracking equals 1
+    status_t dump(String8& result, const char* prefix);
+
+protected:
+    // build the key name to register in GuiExt Service
+    String8 getKeyName() const;
+
+private:
+    // if trackMe needed
+    bool mIsTracking;
+};
+
+
+}; // namespace android
+#endif
diff --git a/libs/gui/Android.mk b/libs/gui/Android.mk
index 49ea3e7f2..e6153d8be 100644
--- a/libs/gui/Android.mk
+++ b/libs/gui/Android.mk
@@ -56,7 +56,6 @@ LOCAL_SRC_FILES := \
 	DisplayEventReceiver.cpp \
 	GLConsumer.cpp \
 	GraphicBufferAlloc.cpp \
-	GraphicsEnv.cpp \
 	GuiConfig.cpp \
 	IDisplayEventConnection.cpp \
 	IGraphicBufferAlloc.cpp \
diff --git a/libs/gui/BufferQueueCore.cpp b/libs/gui/BufferQueueCore.cpp
index d610971b9..b61e851e0 100644
--- a/libs/gui/BufferQueueCore.cpp
+++ b/libs/gui/BufferQueueCore.cpp
@@ -59,7 +59,6 @@ BufferQueueCore::BufferQueueCore(const sp<IGraphicBufferAlloc>& allocator) :
     mConsumerListener(),
     mConsumerUsageBits(0),
     mConnectedApi(NO_CONNECTED_API),
-    mLinkedToDeath(),
     mConnectedProducerListener(),
     mSlots(),
     mQueue(),
diff --git a/libs/gui/BufferQueueProducer.cpp b/libs/gui/BufferQueueProducer.cpp
index 86d48a16e..75042ea19 100644
--- a/libs/gui/BufferQueueProducer.cpp
+++ b/libs/gui/BufferQueueProducer.cpp
@@ -1131,11 +1131,8 @@ status_t BufferQueueProducer::connect(const sp<IProducerListener>& listener,
                         BQ_LOGE("connect: linkToDeath failed: %s (%d)",
                                 strerror(-status), status);
                     }
-                    mCore->mLinkedToDeath = listener;
                 }
-                if (listener->needsReleaseNotify()) {
                     mCore->mConnectedProducerListener = listener;
-                }
             }
             break;
         default:
@@ -1198,9 +1195,9 @@ status_t BufferQueueProducer::disconnect(int api, DisconnectMode mode) {
                     mCore->freeAllBuffersLocked();
 
                     // Remove our death notification callback if we have one
-                    if (mCore->mLinkedToDeath != NULL) {
+                    if (mCore->mConnectedProducerListener != NULL) {
                         sp<IBinder> token =
-                                IInterface::asBinder(mCore->mLinkedToDeath);
+                                IInterface::asBinder(mCore->mConnectedProducerListener);
                         // This can fail if we're here because of the death
                         // notification, but we just ignore it
                         token->unlinkToDeath(
@@ -1208,7 +1205,6 @@ status_t BufferQueueProducer::disconnect(int api, DisconnectMode mode) {
                     }
                     mCore->mSharedBufferSlot =
                             BufferQueueCore::INVALID_BUFFER_SLOT;
-                    mCore->mLinkedToDeath = NULL;
                     mCore->mConnectedProducerListener = NULL;
                     mCore->mConnectedApi = BufferQueueCore::NO_CONNECTED_API;
                     mCore->mConnectedPid = -1;
diff --git a/libs/gui/ConsumerBase.cpp b/libs/gui/ConsumerBase.cpp
index 3cf307834..805a10d1b 100644
--- a/libs/gui/ConsumerBase.cpp
+++ b/libs/gui/ConsumerBase.cpp
@@ -314,23 +314,10 @@ status_t ConsumerBase::addReleaseFenceLocked(int slot,
 
     if (!mSlots[slot].mFence.get()) {
         mSlots[slot].mFence = fence;
-        return OK;
-    }
-
-    auto signaled = mSlots[slot].mFence->hasSignaled();
-
-    if (!signaled) {
-        CB_LOGE("fence has invalid state");
-        return BAD_VALUE;
-    }
-
-    if (*signaled) {
-        mSlots[slot].mFence = fence;
     } else {
-        char fenceName[32] = {};
-        snprintf(fenceName, 32, "%.28s:%d", mName.string(), slot);
         sp<Fence> mergedFence = Fence::merge(
-                fenceName, mSlots[slot].mFence, fence);
+                String8::format("%.28s:%d", mName.string(), slot),
+                mSlots[slot].mFence, fence);
         if (!mergedFence.get()) {
             CB_LOGE("failed to merge release fences");
             // synchronization is broken, the best we can do is hope fences
diff --git a/libs/gui/GLConsumer.cpp b/libs/gui/GLConsumer.cpp
index 10e999c22..aa0db4506 100644
--- a/libs/gui/GLConsumer.cpp
+++ b/libs/gui/GLConsumer.cpp
@@ -1228,19 +1228,14 @@ EGLImageKHR GLConsumer::EglImage::createImage(EGLDisplay dpy,
         EGL_NONE,
     };
     if (!crop.isValid()) {
-        // No crop rect to set, so leave the crop out of the attrib array. Make
-        // sure to propagate the protected content attrs if they are set.
-        attrs[2] = attrs[10];
-        attrs[3] = attrs[11];
-        attrs[4] = EGL_NONE;
+        // No crop rect to set, so terminate the attrib array before the crop.
+        attrs[2] = EGL_NONE;
     } else if (!isEglImageCroppable(crop)) {
         // The crop rect is not at the origin, so we can't set the crop on the
         // EGLImage because that's not allowed by the EGL_ANDROID_image_crop
         // extension.  In the future we can add a layered extension that
         // removes this restriction if there is hardware that can support it.
-        attrs[2] = attrs[10];
-        attrs[3] = attrs[11];
-        attrs[4] = EGL_NONE;
+        attrs[2] = EGL_NONE;
     }
     eglInitialize(dpy, 0, 0);
     EGLImageKHR image = eglCreateImageKHR(dpy, EGL_NO_CONTEXT,
diff --git a/libs/gui/IGraphicBufferProducer.cpp b/libs/gui/IGraphicBufferProducer.cpp
index 1a08130c4..fca6549c8 100644
--- a/libs/gui/IGraphicBufferProducer.cpp
+++ b/libs/gui/IGraphicBufferProducer.cpp
@@ -26,7 +26,6 @@
 #include <binder/Parcel.h>
 #include <binder/IInterface.h>
 
-#include <gui/BufferQueueDefs.h>
 #include <gui/IGraphicBufferProducer.h>
 #include <gui/IProducerListener.h>
 
@@ -207,12 +206,6 @@ class BpGraphicBufferProducer : public BpInterface<IGraphicBufferProducer>
 
         *slot = reply.readInt32();
         result = reply.readInt32();
-        if (result == NO_ERROR &&
-                (*slot < 0 || *slot >= BufferQueueDefs::NUM_BUFFER_SLOTS)) {
-            ALOGE("attachBuffer returned invalid slot %d", *slot);
-            android_errorWriteLog(0x534e4554, "37478824");
-            return UNKNOWN_ERROR;
-        }
 
         return result;
     }
diff --git a/libs/gui/IProducerListener.cpp b/libs/gui/IProducerListener.cpp
index da54ce1c2..81adc9544 100644
--- a/libs/gui/IProducerListener.cpp
+++ b/libs/gui/IProducerListener.cpp
@@ -22,7 +22,6 @@ namespace android {
 
 enum {
     ON_BUFFER_RELEASED = IBinder::FIRST_CALL_TRANSACTION,
-    NEEDS_RELEASE_NOTIFY,
 };
 
 class BpProducerListener : public BpInterface<IProducerListener>
@@ -38,23 +37,6 @@ class BpProducerListener : public BpInterface<IProducerListener>
         data.writeInterfaceToken(IProducerListener::getInterfaceDescriptor());
         remote()->transact(ON_BUFFER_RELEASED, data, &reply, IBinder::FLAG_ONEWAY);
     }
-
-    virtual bool needsReleaseNotify() {
-        bool result;
-        Parcel data, reply;
-        data.writeInterfaceToken(IProducerListener::getInterfaceDescriptor());
-        status_t err = remote()->transact(NEEDS_RELEASE_NOTIFY, data, &reply);
-        if (err != NO_ERROR) {
-            ALOGE("IProducerListener: binder call \'needsReleaseNotify\' failed");
-            return true;
-        }
-        err = reply.readBool(&result);
-        if (err != NO_ERROR) {
-            ALOGE("IProducerListener: malformed binder reply");
-            return true;
-        }
-        return result;
-    }
 };
 
 // Out-of-line virtual method definition to trigger vtable emission in this
@@ -70,16 +52,8 @@ status_t BnProducerListener::onTransact(uint32_t code, const Parcel& data,
             CHECK_INTERFACE(IProducerListener, data, reply);
             onBufferReleased();
             return NO_ERROR;
-        case NEEDS_RELEASE_NOTIFY:
-            CHECK_INTERFACE(IProducerListener, data, reply);
-            reply->writeBool(needsReleaseNotify());
-            return NO_ERROR;
     }
     return BBinder::onTransact(code, data, reply, flags);
 }
 
-bool BnProducerListener::needsReleaseNotify() {
-    return true;
-}
-
 } // namespace android
diff --git a/libs/gui/Surface.cpp b/libs/gui/Surface.cpp
index d423d124a..17c18972a 100644
--- a/libs/gui/Surface.cpp
+++ b/libs/gui/Surface.cpp
@@ -306,12 +306,6 @@ int Surface::dequeueBuffer(android_native_buffer_t** buffer, int* fenceFd) {
         return result;
     }
 
-    if (buf < 0 || buf >= NUM_BUFFER_SLOTS) {
-        ALOGE("dequeueBuffer: IGraphicBufferProducer returned invalid slot number %d", buf);
-        android_errorWriteLog(0x534e4554, "36991414"); // SafetyNet logging
-        return FAILED_TRANSACTION;
-    }
-
     Mutex::Autolock lock(mMutex);
 
     sp<GraphicBuffer>& gbuf(mSlots[buf].buffer);
diff --git a/libs/ui/Android.mk b/libs/ui/Android.mk
index 635341398..8c76c00fb 100644
--- a/libs/ui/Android.mk
+++ b/libs/ui/Android.mk
@@ -16,7 +16,7 @@ LOCAL_PATH := $(call my-dir)
 include $(CLEAR_VARS)
 
 LOCAL_CLANG := true
-LOCAL_CPPFLAGS := -std=c++1y -Weverything -Werror
+LOCAL_CPPFLAGS := -std=c++1y -Weverything
 # LOCAL_SANITIZE := integer
 
 LOCAL_SDCLANG_LTO := true
@@ -48,7 +48,10 @@ LOCAL_SRC_FILES := \
 	PixelFormat.cpp \
 	Rect.cpp \
 	Region.cpp \
-	UiConfig.cpp
+	UiConfig.cpp \
+	mediatek/Fence.cpp \
+	mediatek/IDumpTunnel.cpp \
+	mediatek/RefBaseDump.cpp
 
 LOCAL_SHARED_LIBRARIES := \
 	libbinder \
diff --git a/libs/ui/Fence.cpp b/libs/ui/Fence.cpp
index 5531b238f..c55abafb7 100644
--- a/libs/ui/Fence.cpp
+++ b/libs/ui/Fence.cpp
@@ -67,12 +67,15 @@ status_t Fence::waitForever(const char* logname) {
     if (err < 0 && errno == ETIME) {
         ALOGE("%s: fence %d didn't signal in %u ms", logname, mFenceFd,
                 warningTimeout);
+	dump(mFenceFd);
         err = sync_wait(mFenceFd, TIMEOUT_NEVER);
     }
     return err < 0 ? -errno : status_t(NO_ERROR);
 }
 
-sp<Fence> Fence::merge(const char* name, const sp<Fence>& f1,
+
+
+sp<Fence> Fence::merge(const String8& name, const sp<Fence>& f1,
         const sp<Fence>& f2) {
     ATRACE_CALL();
     int result;
@@ -80,29 +83,24 @@ sp<Fence> Fence::merge(const char* name, const sp<Fence>& f1,
     // valid fence (e.g. NO_FENCE) we merge the one valid fence with itself so
     // that a new fence with the given name is created.
     if (f1->isValid() && f2->isValid()) {
-        result = sync_merge(name, f1->mFenceFd, f2->mFenceFd);
+        result = sync_merge(name.string(), f1->mFenceFd, f2->mFenceFd);
     } else if (f1->isValid()) {
-        result = sync_merge(name, f1->mFenceFd, f1->mFenceFd);
+        result = sync_merge(name.string(), f1->mFenceFd, f1->mFenceFd);
     } else if (f2->isValid()) {
-        result = sync_merge(name, f2->mFenceFd, f2->mFenceFd);
+        result = sync_merge(name.string(), f2->mFenceFd, f2->mFenceFd);
     } else {
         return NO_FENCE;
     }
     if (result == -1) {
         status_t err = -errno;
         ALOGE("merge: sync_merge(\"%s\", %d, %d) returned an error: %s (%d)",
-                name, f1->mFenceFd, f2->mFenceFd,
+                name.string(), f1->mFenceFd, f2->mFenceFd,
                 strerror(-err), err);
         return NO_FENCE;
     }
     return sp<Fence>(new Fence(result));
 }
 
-sp<Fence> Fence::merge(const String8& name, const sp<Fence>& f1,
-        const sp<Fence>& f2) {
-    return merge(name.string(), f1, f2);
-}
-
 int Fence::dup() const {
     return ::dup(mFenceFd);
 }
@@ -162,7 +160,7 @@ status_t Fence::unflatten(void const*& buffer, size_t& size, int const*& fds, si
         return INVALID_OPERATION;
     }
 
-    if (size < getFlattenedSize()) {
+    if (size < 1) {
         return NO_MEMORY;
     }
 
diff --git a/libs/ui/mediatek/Fence.cpp b/libs/ui/mediatek/Fence.cpp
new file mode 100644
index 000000000..1b832deed
--- /dev/null
+++ b/libs/ui/mediatek/Fence.cpp
@@ -0,0 +1,58 @@
+#define LOG_TAG "Fence"
+
+#include <inttypes.h>
+#include <sync/sync.h>
+#include <ui/Fence.h>
+#include <unistd.h>
+
+#include <cutils/log.h>
+
+// ---------------------------------------------------------------------------
+
+static const char* findKeyWord(const char* msg) {
+    android::String8 obj_name(msg);
+    obj_name.toLower();
+    const char* OBJ_NAME = obj_name.string();
+
+    // NOTE: keep these keywords in sync with MOF
+    android::String8 keyword("timeline_");
+    if (strstr(OBJ_NAME, "surfaceflinger")) {
+        keyword.append("SurfaceFlinger");
+    } else if (strstr(OBJ_NAME, "ovl_timeline")) {
+        keyword.append("ovl_timeline");
+    } else if (strstr(OBJ_NAME, "mali")) {
+        keyword.append("mali");
+    }
+
+    return keyword.string();
+}
+
+// ---------------------------------------------------------------------------
+
+namespace android {
+
+void Fence::dump(int fd) {
+    if (-1 == fd) return;
+
+    struct sync_fence_info_data *info = sync_fence_info(fd);
+    if (info) {
+        struct sync_pt_info *pt_info = NULL;
+        // status: active(0) signaled(1) error(<0)
+        ALOGI("fence(%s) status(%d)", info->name, info->status);
+
+        // iterate active/error sync points
+        while ((pt_info = sync_pt_info(info, pt_info))) {
+            if (NULL != pt_info && pt_info->status <= 0) {
+                uint64_t ts_sec = pt_info->timestamp_ns / 1000000000LL;
+                uint64_t ts_usec = (pt_info->timestamp_ns % 1000000000LL) / 1000LL;
+
+                ALOGI("sync point: timeline(%s) drv(%s) status(%d) sync_drv(%u) timestamp(%" PRIu64 ".%06" PRIu64 ")",
+                    pt_info->obj_name, pt_info->driver_name, pt_info->status,
+                    *reinterpret_cast<uint32_t*>(pt_info->driver_data), ts_sec, ts_usec);
+            }
+        }
+        sync_fence_info_free(info);
+    }
+}
+
+} // namespace android
diff --git a/libs/ui/mediatek/IDumpTunnel.cpp b/libs/ui/mediatek/IDumpTunnel.cpp
new file mode 100644
index 000000000..1f1d8361c
--- /dev/null
+++ b/libs/ui/mediatek/IDumpTunnel.cpp
@@ -0,0 +1,116 @@
+#define LOG_TAG "DumpTunnel"
+
+#define MTK_LOG_ENABLE 1
+#include <dlfcn.h>
+#include <utils/String8.h>
+#include <binder/Parcel.h>
+#include <cutils/log.h>
+#include <ui/mediatek/IDumpTunnel.h>
+
+namespace android {
+
+// client : proxy GuiEx class
+class BpDumpTunnel : public BpInterface<IDumpTunnel> {
+public:
+    BpDumpTunnel(const sp<IBinder>& impl)
+        :   BpInterface<IDumpTunnel>(impl) {
+    }
+
+    virtual ~BpDumpTunnel();
+
+    virtual status_t kickDump(String8& result, const char* prefix) {
+        Parcel data, reply;
+        data.writeInterfaceToken(IDumpTunnel::getInterfaceDescriptor());
+        data.writeString8(result);
+        data.writeCString(prefix);
+        status_t err = remote()->transact(DUMPTUNNEL_DUMP, data, &reply);
+        if (err != NO_ERROR) {
+            ALOGE("kickDump could not contact remote\n");
+            return err;
+        }
+        result = reply.readString8();
+        err = reply.readInt32();
+        return err;
+    }
+};
+
+// Out-of-line virtual method definition to trigger vtable emission in this
+// translation unit (see clang warning -Wweak-vtables)
+BpDumpTunnel::~BpDumpTunnel() {}
+
+IMPLEMENT_META_INTERFACE(DumpTunnel, "DumpTunnel");
+
+status_t BnDumpTunnel::onTransact(uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags) {
+    switch (code) {
+        case DUMPTUNNEL_DUMP: {
+            CHECK_INTERFACE(IDumpTunnel, data, reply);
+            String8 result;
+            const char* prefix = NULL;
+            result = data.readString8();
+            prefix = data.readCString();
+
+            status_t ret = kickDump(result, prefix);
+            reply->writeString8(result);
+            reply->writeInt32(ret);
+            return NO_ERROR;
+        }
+    }
+    return BBinder::onTransact(code, data, reply, flags);
+}
+
+// ----------------------------------------------------------------------------
+
+ANDROID_SINGLETON_STATIC_INSTANCE(DumpTunnelHelper);
+
+DumpTunnelHelper::DumpTunnelHelper() :
+    mSoHandle(NULL),
+    mRegDumpPtr(NULL),
+    mUnregDumpPtr(NULL)
+{
+    typedef bool (*RegDumpPrototype)(const sp<IDumpTunnel>&, const String8&);
+    typedef bool (*UnregDumpPrototype)(const String8&);
+
+    // dlopen must set RTLD_LAZY flag because of performance issue
+    mSoHandle = dlopen("libgui_ext.so", RTLD_LAZY);
+    if (mSoHandle) {
+        mRegDumpPtr = reinterpret_cast<RegDumpPrototype>(dlsym(mSoHandle, "regDump"));
+        mUnregDumpPtr = reinterpret_cast<UnregDumpPrototype>(dlsym(mSoHandle, "unregDump"));
+        if (NULL == mRegDumpPtr) {
+            ALOGE("finding regDump() failed");
+        }
+        if (NULL == mUnregDumpPtr) {
+            ALOGE("finding unregDump() failed");
+        }
+    } else {
+        ALOGE("open libgui_ext failed");
+    }
+}
+
+DumpTunnelHelper::~DumpTunnelHelper() {
+    if(mSoHandle != NULL)
+        dlclose(mSoHandle);
+}
+
+bool DumpTunnelHelper::regDump(const sp<IDumpTunnel>& tunnel, const String8& key) {
+    bool result = false;
+    if (NULL == mRegDumpPtr) {
+        ALOGE("finding regDump() failed");
+        return result;
+    }
+    result = mRegDumpPtr(tunnel, key);
+
+    return result;
+}
+
+bool DumpTunnelHelper::unregDump(const String8& key) {
+    bool result = false;
+    if (NULL == mUnregDumpPtr) {
+        ALOGE("finding unregDump() failed");
+        return result;
+    }
+    result = mUnregDumpPtr(key);
+
+    return result;
+}
+
+};
diff --git a/libs/ui/mediatek/RefBaseDump.cpp b/libs/ui/mediatek/RefBaseDump.cpp
new file mode 100644
index 000000000..8dcd5abe4
--- /dev/null
+++ b/libs/ui/mediatek/RefBaseDump.cpp
@@ -0,0 +1,70 @@
+#define LOG_TAG "RefBaseDump"
+
+#if 0
+#define RBD_LOGV(x, ...) ALOGV(x, ##__VA_ARGS__)
+#define RBD_LOGD(x, ...) ALOGD(x, ##__VA_ARGS__)
+#define RBD_LOGI(x, ...) ALOGI(x, ##__VA_ARGS__)
+#define RBD_LOGW(x, ...) ALOGW(x, ##__VA_ARGS__)
+#define RBD_LOGE(x, ...) ALOGE(x, ##__VA_ARGS__)
+#else
+//#define RBD_LOGV(x, ...)
+//#define RBD_LOGD(x, ...)
+#define RBD_LOGI(x, ...)
+//#define RBD_LOGW(x, ...)
+//#define RBD_LOGE(x, ...)
+#endif
+
+#include <cutils/log.h>
+#include <cutils/properties.h>
+#include <ui/mediatek/RefBaseDump.h>
+
+namespace android {
+
+
+IMPLEMENT_META_GUIEXTMONITOR(RefBaseMonitor, RefBase*, "RB");
+
+RefBaseMonitor::RefBaseMonitor() {
+    char value[PROPERTY_VALUE_MAX];
+    RBD_LOGI("RefBaseMonitor ctor - %p", this);
+    getProcessName();
+    property_get("debug.rb.dump", value, "Mary had a little lamb");
+    mIsTracking = (-1 != mProcessName.find(value));
+}
+
+
+status_t RefBaseMonitor::monitor(RefBase* pRb) {
+    if (mIsTracking) {
+        pRb->trackMe(true, false);
+    }
+    return GuiExtMonitor<RefBaseMonitor, RefBase*>::monitor(pRb);
+}
+
+
+status_t RefBaseMonitor::dump(String8& result, const char* /*prefix*/) {
+    size_t listSz;
+    RefBase* pRb;
+    Mutex::Autolock _l(mLock);
+    RBD_LOGI("RefBaseMonitor Dump - %p", this);
+    listSz = mItemList.size();
+    result.appendFormat("\t  [%8p]    RefCnt   %s", this, mProcessName.string());
+    result.append(mIsTracking ? " <- tracking\n" : "\n");
+    result.append("\t  -----------------------\n");
+
+    for (size_t i = 0; i < listSz; i++) {
+        pRb = mItemList.keyAt(i);
+        if (mIsTracking) {
+            pRb->printRefs();
+        }
+        result.appendFormat("\t   %2zu) %8p %4d\n", i, pRb, pRb->getStrongCount());
+    }
+    result.append("\t*****************************************************\n");
+    return NO_ERROR;
+}
+
+
+String8 RefBaseMonitor::getKeyName() const {
+    return String8::format("RB-%p", this);
+}
+
+
+}; // namespace android
diff --git a/opengl/libs/EGL/Loader.cpp b/opengl/libs/EGL/Loader.cpp
index 4234db823..be272354a 100644
--- a/opengl/libs/EGL/Loader.cpp
+++ b/opengl/libs/EGL/Loader.cpp
@@ -125,11 +125,6 @@ static char const * getProcessCmdline() {
     return NULL;
 }
 
-static void* do_dlopen(const char* path, int mode) {
-    ATRACE_CALL();
-    return dlopen(path, mode);
-}
-
 // ----------------------------------------------------------------------------
 
 Loader::driver_t::driver_t(void* gles)
@@ -170,30 +165,14 @@ status_t Loader::driver_t::set(void* hnd, int32_t api)
 // ----------------------------------------------------------------------------
 
 Loader::Loader()
-    : getProcAddress(NULL),
-      mLibGui(nullptr),
-      mGetDriverNamespace(nullptr)
-{
-    // FIXME: See note in GraphicsEnv.h about android_getDriverNamespace().
-    // libgui should already be loaded in any process that uses libEGL, but
-    // if for some reason it isn't, then we're not going to get a driver
-    // namespace anyway, so don't force it to be loaded.
-    mLibGui = dlopen("libgui.so", RTLD_NOLOAD | RTLD_LOCAL | RTLD_LAZY);
-    if (!mLibGui) {
-        ALOGD("failed to load libgui: %s", dlerror());
-        return;
-    }
-    mGetDriverNamespace = reinterpret_cast<decltype(mGetDriverNamespace)>(
-            dlsym(mLibGui, "android_getDriverNamespace"));
+    : getProcAddress(NULL) {
 }
 
 Loader::~Loader() {
-    if (mLibGui)
-        dlclose(mLibGui);
 }
 
 static void* load_wrapper(const char* path) {
-    void* so = do_dlopen(path, RTLD_NOW | RTLD_LOCAL);
+    void* so = dlopen(path, RTLD_NOW | RTLD_LOCAL);
     ALOGE_IF(!so, "dlopen(\"%s\") failed: %s", path, dlerror());
     return so;
 }
@@ -348,7 +327,9 @@ void Loader::init_api(void* dso,
     }
 }
 
-static void* load_system_driver(const char* kind) {
+void *Loader::load_driver(const char* kind,
+        egl_connection_t* cnx, uint32_t mask)
+{
     ATRACE_CALL();
     class MatchFile {
     public:
@@ -465,7 +446,7 @@ static void* load_system_driver(const char* kind) {
     }
     const char* const driver_absolute_path = absolutePath.string();
 
-    void* dso = do_dlopen(driver_absolute_path, RTLD_NOW | RTLD_LOCAL);
+    void* dso = dlopen(driver_absolute_path, RTLD_NOW | RTLD_LOCAL);
     if (dso == 0) {
         const char* err = dlerror();
         ALOGE("load_driver(%s): %s", driver_absolute_path, err?err:"unknown");
@@ -474,63 +455,11 @@ static void* load_system_driver(const char* kind) {
 
     ALOGD("loaded %s", driver_absolute_path);
 
-    return dso;
-}
-
-static void* do_android_dlopen_ext(const char* path, int mode, const android_dlextinfo* info) {
-    ATRACE_CALL();
-    return android_dlopen_ext(path, mode, info);
-}
-
-static const std::array<const char*, 2> HAL_SUBNAME_KEY_PROPERTIES = {{
-    "ro.hardware.egl",
-    "ro.board.platform",
-}};
-
-static void* load_updated_driver(const char* kind, android_namespace_t* ns) {
-    ATRACE_CALL();
-    const android_dlextinfo dlextinfo = {
-        .flags = ANDROID_DLEXT_USE_NAMESPACE,
-        .library_namespace = ns,
-    };
-    void* so = nullptr;
-    char prop[PROPERTY_VALUE_MAX + 1];
-    for (auto key : HAL_SUBNAME_KEY_PROPERTIES) {
-        if (property_get(key, prop, nullptr) > 0) {
-            String8 name;
-            name.appendFormat("lib%s_%s.so", kind, prop);
-            so = do_android_dlopen_ext(name.string(), RTLD_LOCAL | RTLD_NOW,
-                    &dlextinfo);
-            if (so)
-                return so;
-        }
-    }
-    return nullptr;
-}
-
-void *Loader::load_driver(const char* kind,
-        egl_connection_t* cnx, uint32_t mask)
-{
-    ATRACE_CALL();
-
-    void* dso = nullptr;
-    if (mGetDriverNamespace) {
-        android_namespace_t* ns = mGetDriverNamespace();
-        if (ns) {
-            dso = load_updated_driver(kind, ns);
-        }
-    }
-    if (!dso) {
-        dso = load_system_driver(kind);
-        if (!dso)
-            return NULL;
-    }
-
     if (mask & EGL) {
         getProcAddress = (getProcAddressType)dlsym(dso, "eglGetProcAddress");
 
         ALOGE_IF(!getProcAddress,
-                "can't find eglGetProcAddress() in EGL driver library");
+                "can't find eglGetProcAddress() in %s", driver_absolute_path);
 
         egl_t* egl = &cnx->egl;
         __eglMustCastToProperFunctionPointerType* curr =
diff --git a/opengl/libs/EGL/Loader.h b/opengl/libs/EGL/Loader.h
index 04a8e413a..46ccd06b2 100644
--- a/opengl/libs/EGL/Loader.h
+++ b/opengl/libs/EGL/Loader.h
@@ -25,8 +25,6 @@
 #include <utils/Singleton.h>
 #include <utils/String8.h>
 
-#include <gui/GraphicsEnv.h>
-
 #include <EGL/egl.h>
 
 // ----------------------------------------------------------------------------
@@ -56,9 +54,6 @@ class Loader : public Singleton<Loader>
     
     getProcAddressType getProcAddress;
 
-    void* mLibGui;
-    decltype(android_getDriverNamespace)* mGetDriverNamespace;
-
 public:
     ~Loader();
     
diff --git a/opengl/libs/EGL/eglApi.cpp b/opengl/libs/EGL/eglApi.cpp
index 0cd8b0235..4cd501399 100644
--- a/opengl/libs/EGL/eglApi.cpp
+++ b/opengl/libs/EGL/eglApi.cpp
@@ -1867,6 +1867,12 @@ EGLClientBuffer eglCreateNativeClientBufferANDROID(const EGLint *attrib_list)
                     if (value & EGL_NATIVE_BUFFER_USAGE_TEXTURE_BIT_ANDROID) {
                         usage |= GRALLOC_USAGE_HW_TEXTURE;
                     }
+		    // The buffer must be used for either a texture or a
+                    // renderbuffer.
+                    if ((value & EGL_NATIVE_BUFFER_USAGE_RENDERBUFFER_BIT_ANDROID) &&
+                        (value & EGL_NATIVE_BUFFER_USAGE_TEXTURE_BIT_ANDROID)) {
+                        return setError(EGL_BAD_PARAMETER, (EGLClientBuffer)0);
+                    }
                     break;
                 default:
                     return setError(EGL_BAD_PARAMETER, (EGLClientBuffer)0);
diff --git a/vulkan/libvulkan/driver.cpp b/vulkan/libvulkan/driver.cpp
index 0a7f0f832..98d8a1ff7 100644
--- a/vulkan/libvulkan/driver.cpp
+++ b/vulkan/libvulkan/driver.cpp
@@ -26,7 +26,6 @@
 
 #include <android/dlext.h>
 #include <cutils/properties.h>
-#include <gui/GraphicsEnv.h>
 
 #include "driver.h"
 #include "stubhal.h"
@@ -129,81 +128,17 @@ class CreateInfoWrapper {
 
 Hal Hal::hal_;
 
-void* LoadLibrary(const android_dlextinfo& dlextinfo,
-                  const char* subname,
-                  int subname_len) {
-    const char kLibFormat[] = "vulkan.%*s.so";
-    char* name = static_cast<char*>(
-        alloca(sizeof(kLibFormat) + static_cast<size_t>(subname_len)));
-    sprintf(name, kLibFormat, subname_len, subname);
-    return android_dlopen_ext(name, RTLD_LOCAL | RTLD_NOW, &dlextinfo);
-}
-
-const std::array<const char*, 2> HAL_SUBNAME_KEY_PROPERTIES = {{
-    "ro.hardware." HWVULKAN_HARDWARE_MODULE_ID,
-    "ro.board.platform",
-}};
-
-int LoadUpdatedDriver(const hw_module_t** module) {
-    const android_dlextinfo dlextinfo = {
-        .flags = ANDROID_DLEXT_USE_NAMESPACE,
-        .library_namespace = android::GraphicsEnv::getInstance().getDriverNamespace(),
-    };
-    if (!dlextinfo.library_namespace)
-        return -ENOENT;
-
-    void* so = nullptr;
-    char prop[PROPERTY_VALUE_MAX];
-    for (auto key : HAL_SUBNAME_KEY_PROPERTIES) {
-        int prop_len = property_get(key, prop, nullptr);
-        if (prop_len > 0) {
-            so = LoadLibrary(dlextinfo, prop, prop_len);
-            if (so)
-                break;
-        }
-    }
-    if (!so)
-        return -ENOENT;
-
-    hw_module_t* hmi = static_cast<hw_module_t*>(dlsym(so, HAL_MODULE_INFO_SYM_AS_STR));
-    if (!hmi) {
-        ALOGE("couldn't find symbol '%s' in HAL library: %s", HAL_MODULE_INFO_SYM_AS_STR, dlerror());
-        dlclose(so);
-        return -EINVAL;
-    }
-    if (strcmp(hmi->id, HWVULKAN_HARDWARE_MODULE_ID) != 0) {
-        ALOGE("HAL id '%s' != '%s'", hmi->id, HWVULKAN_HARDWARE_MODULE_ID);
-        dlclose(so);
-        return -EINVAL;
-    }
-    hmi->dso = so;
-    *module = hmi;
-    ALOGD("loaded updated driver");
-    return 0;
-}
-
 bool Hal::Open() {
     ALOG_ASSERT(!hal_.dev_, "OpenHAL called more than once");
 
     // Use a stub device unless we successfully open a real HAL device.
     hal_.dev_ = &stubhal::kDevice;
 
-    // Use stub HAL if vulkan is disabled
-    bool disableVulkan = property_get_bool("persist.graphics.vulkan.disable", false);
-    if (disableVulkan == true) {
-        ALOGI("no Vulkan HAL present, using stub HAL");
-        return true;
-    }
-
-    int result;
-    const hwvulkan_module_t* module = nullptr;
-
-    result = LoadUpdatedDriver(reinterpret_cast<const hw_module_t**>(&module));
-    if (result == -ENOENT) {
-        result = hw_get_module(HWVULKAN_HARDWARE_MODULE_ID, reinterpret_cast<const hw_module_t**>(&module));
-    }
+    const hwvulkan_module_t* module;
+    int result =
+        hw_get_module("vulkan", reinterpret_cast<const hw_module_t**>(&module));
     if (result != 0) {
-        ALOGV("unable to load Vulkan HAL, using stub HAL (result=%d)", result);
+        ALOGI("no Vulkan HAL present, using stub HAL");
         return true;
     }
 