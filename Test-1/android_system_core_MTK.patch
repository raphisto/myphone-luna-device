From 46b32d1807b7424a21416bffb579d113595c06e0 Mon Sep 17 00:00:00 2001
From: adi766 <adityakumarteli7846@gmail.com>
Date: Sat, 23 Sep 2017 07:37:38 +0000
Subject: [PATCH] Mediatek: Correctly report battery voltage

---
 healthd/BatteryMonitor.cpp | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/healthd/BatteryMonitor.cpp b/healthd/BatteryMonitor.cpp
index 1a47af84c..7c43e2891 100644
--- a/healthd/BatteryMonitor.cpp
+++ b/healthd/BatteryMonitor.cpp
@@ -232,7 +232,11 @@ bool BatteryMonitor::update(void) {
     props.batteryLevel = mBatteryFixedCapacity ?
         mBatteryFixedCapacity :
         getIntField(mHealthdConfig->batteryCapacityPath);
+#ifndef MTK_HARDWARE
     props.batteryVoltage = getIntField(mHealthdConfig->batteryVoltagePath) / 1000;
+#else
+    props.batteryVoltage = getIntField(mHealthdConfig->batteryVoltagePath);
+#endif
 
     if (!mHealthdConfig->batteryCurrentNowPath.isEmpty())
         props.batteryCurrent = getIntField(mHealthdConfig->batteryCurrentNowPath) / 1000;

From 5c6c6822d5261eaff7379990011b314334fa3518 Mon Sep 17 00:00:00 2001
From: adi766 <adityakumarteli7846@gmail.com>
Date: Sat, 23 Sep 2017 07:39:57 +0000
Subject: [PATCH] mkbootimg: Support MTK boot.img format

---
 mkbootimg/mkbootimg     | 31 ++++++++++++++++++++++---------
 mkbootimg/unpackbootimg | 11 +++++++++++
 2 files changed, 33 insertions(+), 9 deletions(-)

diff --git a/mkbootimg/mkbootimg b/mkbootimg/mkbootimg
index 5b3b7930e..ede83f91a 100755
--- a/mkbootimg/mkbootimg
+++ b/mkbootimg/mkbootimg
@@ -46,18 +46,20 @@ def pad_file(f, padding):
 
 
 def write_header(args):
+    mtk_size = 512 if args.mtk is not None else 0
+
     BOOT_MAGIC = 'ANDROID!'.encode()
     args.output.write(pack('8s', BOOT_MAGIC))
     args.output.write(pack('10I',
-        filesize(args.kernel),                          # size in bytes
+        filesize(args.kernel), + mtk_size,              # size in bytes
         args.base + args.kernel_offset,                 # physical load addr
-        filesize(args.ramdisk),                         # size in bytes
+        filesize(args.ramdisk), + mtk_size,             # size in bytes
         args.base + args.ramdisk_offset,                # physical load addr
-        filesize(args.second),                          # size in bytes
+        filesize(args.second), + mtk_size,              # size in bytes
         args.base + args.second_offset,                 # physical load addr
         args.base + args.tags_offset,                   # physical addr for kernel tags
         args.pagesize,                                  # flash page size we assume
-        filesize(args.dt),                              # size in bytes
+        filesize(args.dt), + mtk_size,                  # size in bytes
         (args.os_version << 11) | args.os_patch_level)) # os version and patch level
     args.output.write(pack('16s', args.board.encode())) # asciiz product name
     args.output.write(pack('512s', args.cmdline[:512].encode()))
@@ -90,9 +92,16 @@ class ValidateStrLenAction(Action):
         setattr(namespace, self.dest, values)
 
 
-def write_padded_file(f_out, f_in, padding):
+def write_padded_file(f_out, f_in, padding, is_mtk=False, mtk_id=''):
     if f_in is None:
         return
+
+	if is_mtk:
+        mtk_hdr = pack('<II32s', 0x58881688, filesize(f_in), mtk_id.encode())
+        mtk_hdr_pad = b'\xff' * (512 - len(mtk_hdr))
+        f_out.write(mtk_hdr)
+        f_out.write(mtk_hdr_pad)
+
     f_out.write(f_in.read())
     pad_file(f_out, padding)
 
@@ -154,14 +163,18 @@ def parse_cmdline():
     parser.add_argument('--dt', help='path to the device tree image', type=FileType('rb'))
     parser.add_argument('-o', '--output', help='output file name', type=FileType('wb'),
                         required=True)
+	parser.add_argument('--mtk', help='MTK flavor of image to create', default=None,
+                        choices=['boot', 'recovery', ])
     return parser.parse_args()
 
 
 def write_data(args):
-    write_padded_file(args.output, args.kernel, args.pagesize)
-    write_padded_file(args.output, args.ramdisk, args.pagesize)
-    write_padded_file(args.output, args.second, args.pagesize)
-    write_padded_file(args.output, args.dt, args.pagesize)
+    is_mtk = args.mtk is not None
+    ramdisk_id = 'ROOTFS' if args.mtk == 'boot' else 'RECOVERY'
+    write_padded_file(args.output, args.kernel, args.pagesize, is_mtk, 'KERNEL')
+    write_padded_file(args.output, args.ramdisk, args.pagesize, is_mtk, ramdisk_id)
+    write_padded_file(args.output, args.second, args.pagesize, is_mtk, '')
+    write_padded_file(args.output, args.dt, args.pagesize, is_mtk, '')
 
 
 def main():
diff --git a/mkbootimg/unpackbootimg b/mkbootimg/unpackbootimg
index b5dc66393..7d563ebbd 100755
--- a/mkbootimg/unpackbootimg
+++ b/mkbootimg/unpackbootimg
@@ -112,6 +112,8 @@ def parse_cmdline():
     parser.add_argument('-o', '--output', help='output directory', default='./')
     parser.add_argument('--pagesize', help='page size', type=parse_int,
                         choices=[2**i for i in range(11,18)], default=0)
+	parser.add_argument('--mtk', help='skip MTK header if present', type=parse_int,
+                        choices=[1], default=0)
     return parser.parse_args()
 
 def seek_padding(f, size, pagesize):
@@ -122,6 +124,15 @@ def seek_padding(f, size, pagesize):
 
 def write_input_to_file(args, filename, size):
     with open(filename, 'wb') as f_out:
+	    if args.mtk:
+            # skip MTK header if present
+            maybe_mtk_magic = args.input.read(4)
+            if maybe_mtk_magic == '\x88\x16\x88\x58':
+                # skip rest of MTK header
+                args.input.seek(512 - 4, 1)
+                size -= 512
+            else:
+                args.input.seek(-4, 1)
         f_out.write(args.input.read(size))
 
     seek_padding(args.input, size, args.pagesize)

From 7219fe8460cce0954eaea22c97c95ec79102ce30 Mon Sep 17 00:00:00 2001
From: adi766 <adityakumarteli7846@gmail.com>
Date: Sat, 23 Sep 2017 07:43:06 +0000
Subject: [PATCH] Init: Re-allow services without selinux contexts defined

---
 init/init.cpp    | 4 +++-
 init/service.cpp | 2 ++
 2 files changed, 5 insertions(+), 1 deletion(-)

diff --git a/init/init.cpp b/init/init.cpp
index 7a370596e..7d8f6ed84 100755
--- a/init/init.cpp
+++ b/init/init.cpp
@@ -440,6 +440,7 @@ static void selinux_init_all_handles(void)
     sehandle_prop = selinux_android_prop_context_handle();
 }
 
+#if 0
 enum selinux_enforcing_status { SELINUX_PERMISSIVE, SELINUX_ENFORCING };
 
 static selinux_enforcing_status selinux_status_from_cmdline() {
@@ -453,11 +454,12 @@ static selinux_enforcing_status selinux_status_from_cmdline() {
 
     return status;
 }
+#endif
 
 static bool selinux_is_enforcing(void)
 {
     if (ALLOW_PERMISSIVE_SELINUX) {
-        return selinux_status_from_cmdline() == SELINUX_ENFORCING;
+        return false;
     }
     return true;
 }
diff --git a/init/service.cpp b/init/service.cpp
index 8127e708d..a09fd8f71 100644
--- a/init/service.cpp
+++ b/init/service.cpp
@@ -371,12 +371,14 @@ bool Service::Start() {
             scon = ret_scon;
             free(ret_scon);
         }
+#if 0
         if (rc == 0 && scon == mycon) {
             ERROR("Service %s does not have a SELinux domain defined.\n", name_.c_str());
             free(mycon);
             free(fcon);
             return false;
         }
+#endif
         free(mycon);
         free(fcon);
         if (rc < 0) {

From 7d24733f311eb3c06084bcd242ead30b95837176 Mon Sep 17 00:00:00 2001
From: adi766 <adityakumarteli7846@gmail.com>
Date: Sat, 23 Sep 2017 07:45:00 +0000
Subject: [PATCH] Return python script

---
 mkbootimg/Android.mk      |  38 +++--
 mkbootimg/bootimg.h       |  15 +-
 mkbootimg/mkbootimg       | 191 -------------------------
 mkbootimg/mkbootimg.c     | 357 ++++++++++++++++++++++++++++++++++++++++++++++
 mkbootimg/unpackbootimg   | 260 ---------------------------------
 mkbootimg/unpackbootimg.c | 234 ++++++++++++++++++++++++++++++
 6 files changed, 627 insertions(+), 468 deletions(-)
 delete mode 100755 mkbootimg/mkbootimg
 create mode 100644 mkbootimg/mkbootimg.c
 delete mode 100755 mkbootimg/unpackbootimg
 create mode 100644 mkbootimg/unpackbootimg.c

diff --git a/mkbootimg/Android.mk b/mkbootimg/Android.mk
index f52297d30..c020323d6 100644
--- a/mkbootimg/Android.mk
+++ b/mkbootimg/Android.mk
@@ -2,21 +2,41 @@
 LOCAL_PATH:= $(call my-dir)
 include $(CLEAR_VARS)
 
-LOCAL_SRC_FILES := mkbootimg
-LOCAL_MODULE_CLASS := EXECUTABLES
-LOCAL_IS_HOST_MODULE := true
+LOCAL_SRC_FILES := mkbootimg.c
+LOCAL_STATIC_LIBRARIES := libmincrypt
+LOCAL_CFLAGS := -Werror
 
 LOCAL_MODULE := mkbootimg
 
-include $(BUILD_PREBUILT)
-
+include $(BUILD_HOST_EXECUTABLE)
 
 include $(CLEAR_VARS)
+LOCAL_SRC_FILES := unpackbootimg.c
+LOCAL_MODULE := unpackbootimg
+include $(BUILD_HOST_EXECUTABLE)
 
-LOCAL_SRC_FILES := unpackbootimg
+include $(CLEAR_VARS)
+LOCAL_SRC_FILES := mkbootimg.c
+LOCAL_STATIC_LIBRARIES := libmincrypt libcutils libc
+LOCAL_MODULE := utility_mkbootimg
+LOCAL_MODULE_TAGS := eng
+LOCAL_MODULE_STEM := mkbootimg
 LOCAL_MODULE_CLASS := EXECUTABLES
-LOCAL_IS_HOST_MODULE := true
+LOCAL_UNSTRIPPED_PATH := $(PRODUCT_OUT)/symbols/utilities
+LOCAL_MODULE_PATH := $(PRODUCT_OUT)/utilities
+LOCAL_FORCE_STATIC_EXECUTABLE := true
+include $(BUILD_EXECUTABLE)
 
-LOCAL_MODULE := unpackbootimg
+include $(CLEAR_VARS)
+LOCAL_SRC_FILES := unpackbootimg.c
+LOCAL_STATIC_LIBRARIES := libcutils libc
+LOCAL_MODULE := utility_unpackbootimg
+LOCAL_MODULE_TAGS := eng
+LOCAL_MODULE_STEM := unpackbootimg
+LOCAL_MODULE_CLASS := EXECUTABLES
+LOCAL_UNSTRIPPED_PATH := $(PRODUCT_OUT)/symbols/utilities
+LOCAL_MODULE_PATH := $(PRODUCT_OUT)/utilities
+LOCAL_FORCE_STATIC_EXECUTABLE := true
+include $(BUILD_EXECUTABLE)
 
-include $(BUILD_PREBUILT)
+$(call dist-for-goals,dist_files,$(LOCAL_BUILT_MODULE))
diff --git a/mkbootimg/bootimg.h b/mkbootimg/bootimg.h
index 60834fed9..b348bf7d8 100644
--- a/mkbootimg/bootimg.h
+++ b/mkbootimg/bootimg.h
@@ -28,6 +28,8 @@ typedef struct boot_img_hdr boot_img_hdr;
 #define BOOT_ARGS_SIZE 512
 #define BOOT_EXTRA_ARGS_SIZE 1024
 
+#define MTK_HEADER_SIZE 512
+
 struct boot_img_hdr
 {
     uint8_t magic[BOOT_MAGIC_SIZE];
@@ -43,14 +45,8 @@ struct boot_img_hdr
 
     uint32_t tags_addr;    /* physical addr for kernel tags */
     uint32_t page_size;    /* flash page size we assume */
-    uint32_t unused;       /* reserved for future expansion: MUST be 0 */
-
-    /* operating system version and security patch level; for
-     * version "A.B.C" and patch level "Y-M-D":
-     * ver = A << 14 | B << 7 | C         (7 bits for each of A, B, C)
-     * lvl = ((Y - 2000) & 127) << 4 | M  (7 bits for Y, 4 bits for M)
-     * os_version = ver << 11 | lvl */
-    uint32_t os_version;
+    uint32_t dt_size;      /* device tree in bytes */
+    uint32_t unused;       /* future expansion: should be 0 */
 
     uint8_t name[BOOT_NAME_SIZE]; /* asciiz product name */
 
@@ -73,10 +69,13 @@ struct boot_img_hdr
 ** +-----------------+
 ** | second stage    | o pages
 ** +-----------------+
+** | device tree     | p pages
+** +-----------------+
 **
 ** n = (kernel_size + page_size - 1) / page_size
 ** m = (ramdisk_size + page_size - 1) / page_size
 ** o = (second_size + page_size - 1) / page_size
+** p = (dt_size + page_size - 1) / page_size
 **
 ** 0. all entities are page_size aligned in flash
 ** 1. kernel and ramdisk are required (size != 0)
diff --git a/mkbootimg/mkbootimg b/mkbootimg/mkbootimg
deleted file mode 100755
index ede83f91a..000000000
--- a/mkbootimg/mkbootimg
+++ /dev/null
@@ -1,191 +0,0 @@
-#!/usr/bin/env python
-# Copyright 2015, The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-from __future__ import print_function
-from sys import argv, exit, stderr
-from argparse import ArgumentParser, FileType, Action
-from os import fstat
-from struct import pack
-from hashlib import sha1
-import sys
-import re
-
-def filesize(f):
-    if f is None:
-        return 0
-    try:
-        return fstat(f.fileno()).st_size
-    except OSError:
-        return 0
-
-
-def update_sha(sha, f):
-    if f:
-        sha.update(f.read())
-        f.seek(0)
-        sha.update(pack('I', filesize(f)))
-    else:
-        sha.update(pack('I', 0))
-
-
-def pad_file(f, padding):
-    pad = (padding - (f.tell() & (padding - 1))) & (padding - 1)
-    f.write(pack(str(pad) + 'x'))
-
-
-def write_header(args):
-    mtk_size = 512 if args.mtk is not None else 0
-
-    BOOT_MAGIC = 'ANDROID!'.encode()
-    args.output.write(pack('8s', BOOT_MAGIC))
-    args.output.write(pack('10I',
-        filesize(args.kernel), + mtk_size,              # size in bytes
-        args.base + args.kernel_offset,                 # physical load addr
-        filesize(args.ramdisk), + mtk_size,             # size in bytes
-        args.base + args.ramdisk_offset,                # physical load addr
-        filesize(args.second), + mtk_size,              # size in bytes
-        args.base + args.second_offset,                 # physical load addr
-        args.base + args.tags_offset,                   # physical addr for kernel tags
-        args.pagesize,                                  # flash page size we assume
-        filesize(args.dt), + mtk_size,                  # size in bytes
-        (args.os_version << 11) | args.os_patch_level)) # os version and patch level
-    args.output.write(pack('16s', args.board.encode())) # asciiz product name
-    args.output.write(pack('512s', args.cmdline[:512].encode()))
-
-    sha = sha1()
-    update_sha(sha, args.kernel)
-    update_sha(sha, args.ramdisk)
-    update_sha(sha, args.second)
-    update_sha(sha, args.dt)
-    img_id = pack('32s', sha.digest())
-
-    args.output.write(img_id)
-    args.output.write(pack('1024s', args.cmdline[512:].encode()))
-    pad_file(args.output, args.pagesize)
-    return img_id
-
-
-class ValidateStrLenAction(Action):
-    def __init__(self, option_strings, dest, nargs=None, **kwargs):
-        if 'maxlen' not in kwargs:
-            raise ValueError('maxlen must be set')
-        self.maxlen = int(kwargs['maxlen'])
-        del kwargs['maxlen']
-        super(ValidateStrLenAction, self).__init__(option_strings, dest, **kwargs)
-
-    def __call__(self, parser, namespace, values, option_string=None):
-        if len(values) > self.maxlen:
-            raise ValueError('String argument too long: max {0:d}, got {1:d}'.
-                format(self.maxlen, len(values)))
-        setattr(namespace, self.dest, values)
-
-
-def write_padded_file(f_out, f_in, padding, is_mtk=False, mtk_id=''):
-    if f_in is None:
-        return
-
-	if is_mtk:
-        mtk_hdr = pack('<II32s', 0x58881688, filesize(f_in), mtk_id.encode())
-        mtk_hdr_pad = b'\xff' * (512 - len(mtk_hdr))
-        f_out.write(mtk_hdr)
-        f_out.write(mtk_hdr_pad)
-
-    f_out.write(f_in.read())
-    pad_file(f_out, padding)
-
-
-def parse_int(x):
-    return int(x, 0)
-
-def parse_os_version(x):
-    match = re.search(r'^(\d{1,3})(?:\.(\d{1,3})(?:\.(\d{1,3}))?)?', x)
-    if match:
-        a = int(match.group(1))
-        b = c = 0
-        if match.lastindex >= 2:
-            b = int(match.group(2))
-        if match.lastindex == 3:
-            c = int(match.group(3))
-        # 7 bits allocated for each field
-        assert a < 128
-        assert b < 128
-        assert c < 128
-        return (a << 14) | (b << 7) | c
-    return 0
-
-def parse_os_patch_level(x):
-    match = re.search(r'^(\d{4})-(\d{2})-(\d{2})', x)
-    if match:
-        y = int(match.group(1)) - 2000
-        m = int(match.group(2))
-        # 7 bits allocated for the year, 4 bits for the month
-        assert y >= 0 and y < 128
-        assert m > 0 and m <= 12
-        return (y << 4) | m
-    return 0
-
-def parse_cmdline():
-    parser = ArgumentParser()
-    parser.add_argument('--kernel', help='path to the kernel', type=FileType('rb'),
-                        required=True)
-    parser.add_argument('--ramdisk', help='path to the ramdisk', type=FileType('rb'))
-    parser.add_argument('--second', help='path to the 2nd bootloader', type=FileType('rb'))
-    parser.add_argument('--cmdline', help='extra arguments to be passed on the '
-                        'kernel command line', default='', action=ValidateStrLenAction, maxlen=1536)
-    parser.add_argument('--base', help='base address', type=parse_int, default=0x10000000)
-    parser.add_argument('--kernel_offset', help='kernel offset', type=parse_int, default=0x00008000)
-    parser.add_argument('--ramdisk_offset', help='ramdisk offset', type=parse_int, default=0x01000000)
-    parser.add_argument('--second_offset', help='2nd bootloader offset', type=parse_int,
-                        default=0x00f00000)
-    parser.add_argument('--os_version', help='operating system version', type=parse_os_version,
-                        default=0)
-    parser.add_argument('--os_patch_level', help='operating system patch level',
-                        type=parse_os_patch_level, default=0)
-    parser.add_argument('--tags_offset', help='tags offset', type=parse_int, default=0x00000100)
-    parser.add_argument('--board', help='board name', default='', action=ValidateStrLenAction,
-                        maxlen=16)
-    parser.add_argument('--pagesize', help='page size', type=parse_int,
-                        choices=[2**i for i in range(11,18)], default=2048)
-    parser.add_argument('--id', help='print the image ID on standard output',
-                        action='store_true')
-    parser.add_argument('--dt', help='path to the device tree image', type=FileType('rb'))
-    parser.add_argument('-o', '--output', help='output file name', type=FileType('wb'),
-                        required=True)
-	parser.add_argument('--mtk', help='MTK flavor of image to create', default=None,
-                        choices=['boot', 'recovery', ])
-    return parser.parse_args()
-
-
-def write_data(args):
-    is_mtk = args.mtk is not None
-    ramdisk_id = 'ROOTFS' if args.mtk == 'boot' else 'RECOVERY'
-    write_padded_file(args.output, args.kernel, args.pagesize, is_mtk, 'KERNEL')
-    write_padded_file(args.output, args.ramdisk, args.pagesize, is_mtk, ramdisk_id)
-    write_padded_file(args.output, args.second, args.pagesize, is_mtk, '')
-    write_padded_file(args.output, args.dt, args.pagesize, is_mtk, '')
-
-
-def main():
-    args = parse_cmdline()
-    img_id = write_header(args)
-    write_data(args)
-    if args.id:
-        if isinstance(img_id, str):
-            # Python 2's struct.pack returns a string, but py3 returns bytes.
-            img_id = [ord(x) for x in img_id]
-        print('0x' + ''.join('{:02x}'.format(c) for c in img_id))
-
-if __name__ == '__main__':
-    main()
diff --git a/mkbootimg/mkbootimg.c b/mkbootimg/mkbootimg.c
new file mode 100644
index 000000000..1bf68e4d5
--- /dev/null
+++ b/mkbootimg/mkbootimg.c
@@ -0,0 +1,357 @@
+/* tools/mkbootimg/mkbootimg.c
+**
+** Copyright 2007, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <stdbool.h>
+
+#include "mincrypt/sha.h"
+#include "bootimg.h"
+
+static void *load_file(const char *fn, unsigned *_sz, int is_mtk, const char *mtk_fn)
+{
+    char *data;
+	char *buf_start;
+    int sz;
+	int buf_sz;
+    int fd;
+
+    data = 0;
+    fd = open(fn, O_RDONLY);
+    if(fd < 0) return 0;
+
+    sz = lseek(fd, 0, SEEK_END);
+    if(sz < 0) goto oops;
+
+    if(lseek(fd, 0, SEEK_SET) != 0) goto oops;
+
+    buf_sz = sz + (is_mtk ? MTK_HEADER_SIZE : 0);
+    data = buf_start = (char*) malloc(buf_sz);
+    if(data == 0) goto oops;
+
+    if (is_mtk) {
+        /* MTK magic */
+        data[0] = 0x88;
+        data[1] = 0x16;
+        data[2] = 0x88;
+        data[3] = 0x58;
+
+        /* file length in little endian */
+        data[4] = sz & 0xFF;
+        data[5] = (sz >> 8) & 0xFF;
+        data[6] = (sz >> 16) & 0xFF;
+        data[7] = (sz >> 24) & 0xFF;
+
+        /* MTK "file name" */
+        strncpy(data + 8, mtk_fn, 32);
+
+        /* MTK header padding */
+        memset(data + 40, 0xff, MTK_HEADER_SIZE - 40);
+
+        buf_start += MTK_HEADER_SIZE;
+    }
+
+    if(read(fd, buf_start, sz) != sz) goto oops;
+    close(fd);
+
+    if(_sz) *_sz = buf_sz;
+    return data;
+
+oops:
+    close(fd);
+    if(data != 0) free(data);
+    return 0;
+}
+
+int usage(void)
+{
+    fprintf(stderr,"usage: mkbootimg\n"
+            "       --kernel <filename>\n"
+            "       [ --ramdisk <filename> ]\n"
+            "       [ --second <2ndbootloader-filename> ]\n"
+            "       [ --cmdline <kernel-commandline> ]\n"
+            "       [ --board <boardname> ]\n"
+            "       [ --base <address> ]\n"
+            "       [ --pagesize <pagesize> ]\n"
+            "       [ --dt <filename> ]\n"
+            "       [ --ramdisk_offset <address> ]\n"
+            "       [ --second_offset <address> ]\n"
+            "       [ --tags_offset <address> ]\n"
+            "       [ --id ]\n"
+			"       [ --mtk <boot|recovery> ]\n"
+            "       -o|--output <filename>\n"
+            );
+    return 1;
+}
+
+
+
+static unsigned char padding[131072] = { 0, };
+
+static void print_id(const uint8_t *id, size_t id_len) {
+    printf("0x");
+    unsigned i = 0;
+    for (i = 0; i < id_len; i++) {
+        printf("%02x", id[i]);
+    }
+    printf("\n");
+}
+
+int write_padding(int fd, unsigned pagesize, unsigned itemsize)
+{
+    unsigned pagemask = pagesize - 1;
+    ssize_t count;
+
+    if((itemsize & pagemask) == 0) {
+        return 0;
+    }
+
+    count = pagesize - (itemsize & pagemask);
+
+    if(write(fd, padding, count) != count) {
+        return -1;
+    } else {
+        return 0;
+    }
+}
+
+int main(int argc, char **argv)
+{
+    boot_img_hdr hdr;
+
+	int is_mtk = 0;
+    int is_mtk_boot = 0;
+    char *kernel_fn = NULL;
+    void *kernel_data = NULL;
+    char *ramdisk_fn = NULL;
+    void *ramdisk_data = NULL;
+    char *second_fn = NULL;
+    void *second_data = NULL;
+    char *cmdline = "";
+    char *bootimg = NULL;
+    char *board = "";
+    char *dt_fn = 0;
+    void *dt_data = 0;
+    uint32_t pagesize = 2048;
+    int fd;
+    SHA_CTX ctx;
+    const uint8_t* sha;
+    uint32_t base           = 0x10000000U;
+    uint32_t kernel_offset  = 0x00008000U;
+    uint32_t ramdisk_offset = 0x01000000U;
+    uint32_t second_offset  = 0x00f00000U;
+    uint32_t tags_offset    = 0x00000100U;
+    size_t cmdlen;
+
+    argc--;
+    argv++;
+
+    memset(&hdr, 0, sizeof(hdr));
+
+    bool get_id = false;
+    while(argc > 0){
+        char *arg = argv[0];
+        if (!strcmp(arg, "--id")) {
+            get_id = true;
+            argc -= 1;
+            argv += 1;
+        } else if(argc >= 2) {
+            char *val = argv[1];
+            argc -= 2;
+            argv += 2;
+            if(!strcmp(arg, "--output") || !strcmp(arg, "-o")) {
+                bootimg = val;
+            } else if(!strcmp(arg, "--kernel")) {
+                kernel_fn = val;
+            } else if(!strcmp(arg, "--ramdisk")) {
+                ramdisk_fn = val;
+            } else if(!strcmp(arg, "--second")) {
+                second_fn = val;
+            } else if(!strcmp(arg, "--cmdline")) {
+                cmdline = val;
+            } else if(!strcmp(arg, "--base")) {
+                base = strtoul(val, 0, 16);
+            } else if(!strcmp(arg, "--kernel_offset")) {
+                kernel_offset = strtoul(val, 0, 16);
+            } else if(!strcmp(arg, "--ramdisk_offset")) {
+                ramdisk_offset = strtoul(val, 0, 16);
+            } else if(!strcmp(arg, "--second_offset")) {
+                second_offset = strtoul(val, 0, 16);
+            } else if(!strcmp(arg, "--tags_offset")) {
+                tags_offset = strtoul(val, 0, 16);
+            } else if(!strcmp(arg, "--board")) {
+                board = val;
+            } else if(!strcmp(arg,"--pagesize")) {
+                pagesize = strtoul(val, 0, 10);
+                if ((pagesize != 2048) && (pagesize != 4096)
+                    && (pagesize != 8192) && (pagesize != 16384)
+                    && (pagesize != 32768) && (pagesize != 65536)
+                    && (pagesize != 131072)) {
+                    fprintf(stderr,"error: unsupported page size %d\n", pagesize);
+                    return -1;
+                }
+            } else if(!strcmp(arg, "--dt")) {
+                dt_fn = val;
+			} else if (!strcmp(arg, "--mtk")) {
+                if (!strcmp(val, "boot")) {
+                    is_mtk = 1;
+                    is_mtk_boot = 1;
+                } else if (!strcmp(val, "recovery")) {
+                    is_mtk = 1;
+                    is_mtk_boot = 0;
+                } else {
+                    return usage();
+                }
+            } else {
+                return usage();
+            }
+        } else {
+            return usage();
+        }
+    }
+    hdr.page_size = pagesize;
+
+    hdr.kernel_addr =  base + kernel_offset;
+    hdr.ramdisk_addr = base + ramdisk_offset;
+    hdr.second_addr =  base + second_offset;
+    hdr.tags_addr =    base + tags_offset;
+
+    if(bootimg == 0) {
+        fprintf(stderr,"error: no output filename specified\n");
+        return usage();
+    }
+
+    if(kernel_fn == 0) {
+        fprintf(stderr,"error: no kernel image specified\n");
+        return usage();
+    }
+
+    if(strlen(board) >= BOOT_NAME_SIZE) {
+        fprintf(stderr,"error: board name too large\n");
+        return usage();
+    }
+
+    strcpy((char *) hdr.name, board);
+
+    memcpy(hdr.magic, BOOT_MAGIC, BOOT_MAGIC_SIZE);
+
+    cmdlen = strlen(cmdline);
+    if(cmdlen > (BOOT_ARGS_SIZE + BOOT_EXTRA_ARGS_SIZE - 2)) {
+        fprintf(stderr,"error: kernel commandline too large\n");
+        return 1;
+    }
+    /* Even if we need to use the supplemental field, ensure we
+     * are still NULL-terminated */
+    strncpy((char *)hdr.cmdline, cmdline, BOOT_ARGS_SIZE - 1);
+    hdr.cmdline[BOOT_ARGS_SIZE - 1] = '\0';
+    if (cmdlen >= (BOOT_ARGS_SIZE - 1)) {
+        cmdline += (BOOT_ARGS_SIZE - 1);
+        strncpy((char *)hdr.extra_cmdline, cmdline, BOOT_EXTRA_ARGS_SIZE);
+    }
+
+    kernel_data = load_file(kernel_fn, &hdr.kernel_size, is_mtk, "KERNEL");
+    if(kernel_data == 0) {
+        fprintf(stderr,"error: could not load kernel '%s'\n", kernel_fn);
+        return 1;
+    }
+
+    if(ramdisk_fn == 0) {
+        ramdisk_data = 0;
+        hdr.ramdisk_size = 0;
+    } else {
+        ramdisk_data = load_file(ramdisk_fn, &hdr.ramdisk_size, is_mtk, is_mtk_boot ? "ROOTFS" : "RECOVERY");
+        if(ramdisk_data == 0) {
+            fprintf(stderr,"error: could not load ramdisk '%s'\n", ramdisk_fn);
+            return 1;
+        }
+    }
+
+    if(second_fn) {
+        second_data = load_file(second_fn, &hdr.second_size, is_mtk, "");
+        if(second_data == 0) {
+            fprintf(stderr,"error: could not load secondstage '%s'\n", second_fn);
+            return 1;
+        }
+    }
+
+    if(dt_fn) {
+        dt_data = load_file(dt_fn, &hdr.dt_size, is_mtk, "");
+        if (dt_data == 0) {
+            fprintf(stderr,"error: could not load device tree image '%s'\n", dt_fn);
+            return 1;
+        }
+    }
+
+    /* put a hash of the contents in the header so boot images can be
+     * differentiated based on their first 2k.
+     */
+    SHA_init(&ctx);
+    SHA_update(&ctx, kernel_data, hdr.kernel_size);
+    SHA_update(&ctx, &hdr.kernel_size, sizeof(hdr.kernel_size));
+    SHA_update(&ctx, ramdisk_data, hdr.ramdisk_size);
+    SHA_update(&ctx, &hdr.ramdisk_size, sizeof(hdr.ramdisk_size));
+    SHA_update(&ctx, second_data, hdr.second_size);
+    SHA_update(&ctx, &hdr.second_size, sizeof(hdr.second_size));
+    if(dt_data) {
+        SHA_update(&ctx, dt_data, hdr.dt_size);
+        SHA_update(&ctx, &hdr.dt_size, sizeof(hdr.dt_size));
+    }
+    sha = SHA_final(&ctx);
+    memcpy(hdr.id, sha,
+           SHA_DIGEST_SIZE > sizeof(hdr.id) ? sizeof(hdr.id) : SHA_DIGEST_SIZE);
+
+    fd = open(bootimg, O_CREAT | O_TRUNC | O_WRONLY, 0644);
+    if(fd < 0) {
+        fprintf(stderr,"error: could not create '%s'\n", bootimg);
+        return 1;
+    }
+
+    if(write(fd, &hdr, sizeof(hdr)) != sizeof(hdr)) goto fail;
+    if(write_padding(fd, pagesize, sizeof(hdr))) goto fail;
+
+    if(write(fd, kernel_data, hdr.kernel_size) != (ssize_t) hdr.kernel_size) goto fail;
+    if(write_padding(fd, pagesize, hdr.kernel_size)) goto fail;
+
+    if(write(fd, ramdisk_data, hdr.ramdisk_size) != (ssize_t) hdr.ramdisk_size) goto fail;
+    if(write_padding(fd, pagesize, hdr.ramdisk_size)) goto fail;
+
+    if(second_data) {
+        if(write(fd, second_data, hdr.second_size) != (ssize_t) hdr.second_size) goto fail;
+        if(write_padding(fd, pagesize, hdr.second_size)) goto fail;
+    }
+
+    if (get_id) {
+        print_id((uint8_t *) hdr.id, sizeof(hdr.id));
+    }
+
+    if(dt_data) {
+        if(write(fd, dt_data, hdr.dt_size) != (ssize_t) hdr.dt_size) goto fail;
+        if(write_padding(fd, pagesize, hdr.dt_size)) goto fail;
+    }
+    return 0;
+
+fail:
+    unlink(bootimg);
+    close(fd);
+    fprintf(stderr,"error: failed writing '%s': %s\n", bootimg,
+            strerror(errno));
+    return 1;
+}
diff --git a/mkbootimg/unpackbootimg b/mkbootimg/unpackbootimg
deleted file mode 100755
index 7d563ebbd..000000000
--- a/mkbootimg/unpackbootimg
+++ /dev/null
@@ -1,260 +0,0 @@
-#!/usr/bin/env python
-# Copyright 2015, The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-from __future__ import print_function
-from sys import exit
-from argparse import ArgumentParser, FileType
-from os import rename, makedirs
-from os.path import basename, exists
-from struct import unpack, calcsize
-import zlib
-
-def ROUNDDOWN(number, alignment):
-    return ((number) & ~((alignment)-1))
-
-class Bunch:
-    def __init__(self, **kwds):
-        self.__dict__.update(kwds)
-
-def auto_unpack(fmt, f):
-    size = calcsize(fmt)
-    data = f.read(size)
-    return unpack(fmt, data[0:size])
-
-def get_magic_off(f):
-    BOOT_MAGIC = 'ANDROID!'.encode()
-
-    for i in range(513):
-        f.seek(i)
-        tmp = f.read(len(BOOT_MAGIC))
-        if tmp == BOOT_MAGIC:
-            print('Android magic found at: %d' % i)
-            return i
-
-    print('Android boot magic not found.');
-    exit(1)
-
-def read_header(args, off):
-    args.input.seek(off)
-    fmt = '8s10I16s512s32s1024s'
-    unpacked = auto_unpack(fmt, args.input)
-
-    parsed = Bunch()
-    parsed.headersz = calcsize(fmt)
-    parsed.magic = unpacked[0]
-    parsed.kernel_size = unpacked[1]
-    parsed.kernel_addr = unpacked[2]
-    parsed.ramdisk_size = unpacked[3]
-    parsed.ramdisk_addr = unpacked[4]
-    parsed.second_size = unpacked[5]
-    parsed.second_addr = unpacked[6]
-    parsed.tags_addr = unpacked[7]
-    parsed.pagesize = unpacked[8]
-    parsed.dt_size = unpacked[9]
-    parsed.name = unpacked[11].partition(b'\0')[0].decode()
-    parsed.cmdline = unpacked[12].partition(b'\0')[0].decode()
-    parsed.id = unpacked[13]
-    parsed.cmdline += unpacked[14].partition(b'\0')[0].decode()
-
-    os_version = unpacked[10]>>11
-    os_patch_level = unpacked[10]&0x7ff
-
-    parsed.os_version = None
-    if os_version != 0:
-        a = (os_version>>14)&0x7f
-        b = (os_version>>7)&0x7f
-        c = os_version&0x7f
-        parsed.os_version = '%d.%d.%d' % (a,b,c)
-
-    parsed.os_patch_level = None
-    if os_patch_level != 0:
-        y = (os_patch_level>>4) + 2000
-        m = os_patch_level&0xf
-        parsed.os_patch_level = '%04d-%02d-%02d' % (y,m,0)
-
-    # find common base of all loading addresses
-    parsed.base = min(parsed.kernel_addr, parsed.ramdisk_addr, parsed.second_addr, parsed.tags_addr)
-    parsed.base = ROUNDDOWN(parsed.base, parsed.pagesize)
-    if (parsed.base&0xffff) == 0x8000:
-        parsed.base -= 0x8000
-
-    # calculate offsets relative to base
-    parsed.kernel_offset = parsed.kernel_addr - parsed.base
-    parsed.ramdisk_offset = parsed.ramdisk_addr - parsed.base
-    parsed.second_offset = parsed.second_addr - parsed.base
-    parsed.tags_offset = parsed.tags_addr - parsed.base
-
-    return parsed
-
-def write_str_to_file(filename, s):
-    with open(filename, 'wb') as f:
-        f.write(s.encode())
-
-def parse_int(x):
-    return int(x, 0)
-
-def parse_cmdline():
-    parser = ArgumentParser()
-    parser.add_argument('-i', '--input', help='input file name', type=FileType('rb'),
-                        required=True)
-    parser.add_argument('-o', '--output', help='output directory', default='./')
-    parser.add_argument('--pagesize', help='page size', type=parse_int,
-                        choices=[2**i for i in range(11,18)], default=0)
-	parser.add_argument('--mtk', help='skip MTK header if present', type=parse_int,
-                        choices=[1], default=0)
-    return parser.parse_args()
-
-def seek_padding(f, size, pagesize):
-    pagemask = pagesize - 1;
-    if((size & pagemask) != 0):
-        count = pagesize - (size & pagemask);
-        f.seek(count, 1);
-
-def write_input_to_file(args, filename, size):
-    with open(filename, 'wb') as f_out:
-	    if args.mtk:
-            # skip MTK header if present
-            maybe_mtk_magic = args.input.read(4)
-            if maybe_mtk_magic == '\x88\x16\x88\x58':
-                # skip rest of MTK header
-                args.input.seek(512 - 4, 1)
-                size -= 512
-            else:
-                args.input.seek(-4, 1)
-        f_out.write(args.input.read(size))
-
-    seek_padding(args.input, size, args.pagesize)
-
-def fix_ramdisk_extension(filename):
-    bytes = []
-    with open(filename, 'rb') as f:
-        data = f.read(2)
-        if(len(data))!=2:
-            return
-        bytes = unpack('BB', data)
-
-    if bytes[0]==0x02 and bytes[1]==0x21:
-        rename(filename, filename+'.lz4')
-    else:
-        rename(filename, filename+'.gz')
-
-def is_gzip_package(filename):
-    bytes = []
-    with open(filename, 'rb') as f:
-        data = f.read(3)
-        if(len(data))!=3:
-            return False
-        bytes = unpack('BBB', data)
-
-    return bytes[0]==0x1f and bytes[1]==0x8b and bytes[2]==0x08
-
-def is_arm64(filename):
-    data = None
-    with open(filename, 'rb') as f:
-        fmt = '2I6Q2I'
-        size = calcsize(fmt)
-        buf = f.read(size)
-        if(len(buf))!=size:
-            return False
-        data = unpack(fmt, buf)
-
-    return data[8]==0x644D5241
-
-def write_data(args, header, off):
-    file_prefix = args.output
-    if file_prefix and file_prefix[-1]!='/':
-        file_prefix += '/'
-    file_prefix += basename(args.input.name) + '-'
-
-    if not exists(args.output):
-        makedirs(args.output)
-
-    write_str_to_file(file_prefix+'cmdline', header.cmdline)
-    write_str_to_file(file_prefix+'base', '%08x' % header.base)
-    write_str_to_file(file_prefix+'kernel_offset', '%08x' % header.kernel_offset)
-    write_str_to_file(file_prefix+'ramdisk_offset', '%08x' % header.ramdisk_offset)
-    write_str_to_file(file_prefix+'second_offset', '%08x' % header.second_offset)
-    write_str_to_file(file_prefix+'tags_offset', '%08x' % header.tags_offset)
-    write_str_to_file(file_prefix+'pagesize', '%d' % header.pagesize)
-    write_str_to_file(file_prefix+'name', header.name)
-    if header.os_version:
-        write_str_to_file(file_prefix+'os_version', header.os_version)
-    if header.os_patch_level:
-        write_str_to_file(file_prefix+'os_patch_level', header.os_patch_level)
-
-    seek_padding(args.input, header.headersz, args.pagesize)
-
-    write_input_to_file(args, file_prefix+'zImage', header.kernel_size)
-    write_input_to_file(args, file_prefix+'ramdisk', header.ramdisk_size)
-    write_input_to_file(args, file_prefix+'second', header.second_size)
-    write_input_to_file(args, file_prefix+'dt', header.dt_size)
-
-    fix_ramdisk_extension(file_prefix+'ramdisk')
-
-    if header.kernel_size >= 2:
-        if is_gzip_package(file_prefix+'zImage'):
-            with open(file_prefix+'zImage', 'rb') as f_in:
-                # seek past gzip header
-                f_in.seek(10)
-
-                # write uncompressed zImage
-                with open(file_prefix+'zImage.gunzip', 'wb') as f_out:
-                    decomp = zlib.decompressobj(-15)
-                    f_out.write(decomp.decompress(f_in.read()))
-
-                # write fdt
-                with open(file_prefix+'zImage.fdt', 'wb') as f_out:
-                    f_out.write(decomp.unused_data[8:])
-
-        elif not is_arm64(file_prefix+'zImage'):
-            with open(file_prefix+'zImage', 'rb') as f_in:
-                # get kernel size
-                f_in.seek(0x28)
-                unpacked = auto_unpack('2I', f_in)
-                zimage_start = unpacked[0]
-                zimage_end = unpacked[1]
-                zimage_size = zimage_end - zimage_start;
-
-                if zimage_size<header.kernel_size:
-                    # write zImage
-                    f_in.seek(0)
-                    with open(file_prefix+'zImage.real', 'wb') as f_out:
-                        f_out.write(f_in.read(zimage_size))
-
-                    # write fdt
-                    with open(file_prefix+'zImage.fdt', 'wb') as f_out:
-                        f_out.write(f_in.read())
-
-def main():
-    args = parse_cmdline()
-    off = get_magic_off(args.input)
-    header = read_header(args, off)
-
-    print('BOARD_KERNEL_CMDLINE %s' % header.cmdline)
-    print('BOARD_KERNEL_BASE %08x' % header.kernel_offset)
-    print('BOARD_RAMDISK_OFFSET %08x' % header.ramdisk_offset)
-    print('BOARD_SECOND_OFFSET %08x' % header.second_offset)
-    print('BOARD_TAGS_OFFSET %08x' % header.tags_offset)
-    print('BOARD_PAGE_SIZE %d' % header.pagesize)
-    print('BOARD_SECOND_SIZE %d' % header.second_size)
-    print('BOARD_DT_SIZE %d' % header.dt_size)
-
-    if args.pagesize == 0:
-        args.pagesize = header.pagesize
-
-    write_data(args, header, off)
-
-if __name__ == '__main__':
-    main()
diff --git a/mkbootimg/unpackbootimg.c b/mkbootimg/unpackbootimg.c
new file mode 100644
index 000000000..1e22c3dda
--- /dev/null
+++ b/mkbootimg/unpackbootimg.c
@@ -0,0 +1,234 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <limits.h>
+#include <libgen.h>
+
+#include "mincrypt/sha.h"
+#include "bootimg.h"
+
+typedef unsigned char byte;
+
+int read_padding(FILE* f, unsigned itemsize, int pagesize)
+{
+    byte* buf = (byte*)malloc(sizeof(byte) * pagesize);
+    unsigned pagemask = pagesize - 1;
+    unsigned count;
+
+    if((itemsize & pagemask) == 0) {
+        free(buf);
+        return 0;
+    }
+
+    count = pagesize - (itemsize & pagemask);
+
+    fread(buf, count, 1, f);
+    free(buf);
+    return count;
+}
+
+void write_string_to_file(char* file, char* string)
+{
+    FILE* f = fopen(file, "w");
+    fwrite(string, strlen(string), 1, f);
+    fwrite("\n", 1, 1, f);
+    fclose(f);
+}
+
+void maybe_skip_mtk_header(FILE* f, int is_mtk)
+{
+    if (!is_mtk) {
+        return;
+    }
+
+    fseek(f, MTK_HEADER_SIZE, SEEK_CUR);
+}
+
+int usage() {
+    printf("usage: unpackbootimg\n");
+    printf("\t-i|--input boot.img\n");
+    printf("\t[ -o|--output output_directory]\n");
+    printf("\t[ -p|--pagesize <size-in-hexadecimal> ]\n");
+	printf("\t[ --mtk 1 ]\n");
+    return 0;
+}
+
+int main(int argc, char** argv)
+{
+    char tmp[PATH_MAX];
+    char* directory = "./";
+    char* filename = NULL;
+    int pagesize = 0;
+	int is_mtk = 0;
+
+    argc--;
+    argv++;
+    while(argc > 0){
+        char *arg = argv[0];
+        char *val = argv[1];
+        argc -= 2;
+        argv += 2;
+        if(!strcmp(arg, "--input") || !strcmp(arg, "-i")) {
+            filename = val;
+        } else if(!strcmp(arg, "--output") || !strcmp(arg, "-o")) {
+            directory = val;
+        } else if(!strcmp(arg, "--pagesize") || !strcmp(arg, "-p")) {
+            pagesize = strtoul(val, 0, 16);
+		} else if (!strcmp(arg, "--mtk")) {
+            if (!strcmp(val, "1")) {
+                is_mtk = 1;
+            }
+
+            return usage();
+        } else {
+            return usage();
+        }
+    }
+    
+    if (filename == NULL) {
+        return usage();
+    }
+    
+    int total_read = 0;
+    FILE* f = fopen(filename, "rb");
+    boot_img_hdr header;
+
+    //printf("Reading header...\n");
+    int i;
+    for (i = 0; i <= 512; i++) {
+        fseek(f, i, SEEK_SET);
+        fread(tmp, BOOT_MAGIC_SIZE, 1, f);
+        if (memcmp(tmp, BOOT_MAGIC, BOOT_MAGIC_SIZE) == 0)
+            break;
+    }
+    total_read = i;
+    if (i > 512) {
+        printf("Android boot magic not found.\n");
+        return 1;
+    }
+    fseek(f, i, SEEK_SET);
+    printf("Android magic found at: %d\n", i);
+
+    fread(&header, sizeof(header), 1, f);
+    printf("BOARD_KERNEL_CMDLINE %s\n", header.cmdline);
+    printf("BOARD_KERNEL_BASE %08x\n", header.kernel_addr - 0x00008000);
+    printf("BOARD_RAMDISK_OFFSET %08x\n", header.ramdisk_addr - header.kernel_addr + 0x00008000);
+    printf("BOARD_SECOND_OFFSET %08x\n", header.second_addr - header.kernel_addr + 0x00008000);
+    printf("BOARD_TAGS_OFFSET %08x\n",header.tags_addr - header.kernel_addr + 0x00008000);
+    printf("BOARD_PAGE_SIZE %d\n", header.page_size);
+    printf("BOARD_SECOND_SIZE %d\n", header.second_size);
+    printf("BOARD_DT_SIZE %d\n", header.dt_size);
+    
+    if (pagesize == 0) {
+        pagesize = header.page_size;
+    }
+    
+    //printf("cmdline...\n");
+    sprintf(tmp, "%s/%s", directory, basename(filename));
+    strcat(tmp, "-cmdline");
+    write_string_to_file(tmp, header.cmdline);
+    
+    //printf("base...\n");
+    sprintf(tmp, "%s/%s", directory, basename(filename));
+    strcat(tmp, "-base");
+    char basetmp[200];
+    sprintf(basetmp, "%08x", header.kernel_addr - 0x00008000);
+    write_string_to_file(tmp, basetmp);
+
+    //printf("ramdisk_offset...\n");
+    sprintf(tmp, "%s/%s", directory, basename(filename));
+    strcat(tmp, "-ramdisk_offset");
+    char ramdisktmp[200];
+    sprintf(ramdisktmp, "%08x", header.ramdisk_addr - header.kernel_addr + 0x00008000);
+    write_string_to_file(tmp, ramdisktmp);
+
+    //printf("second_offset...\n");
+    sprintf(tmp, "%s/%s", directory, basename(filename));
+    strcat(tmp, "-second_offset");
+    char secondtmp[200];
+    sprintf(secondtmp, "%08x", header.second_addr - header.kernel_addr + 0x00008000);
+    write_string_to_file(tmp, secondtmp);
+
+    //printf("tags_offset...\n");
+    sprintf(tmp, "%s/%s", directory, basename(filename));
+    strcat(tmp, "-tags_offset");
+    char tagstmp[200];
+    sprintf(tagstmp, "%08x", header.tags_addr - header.kernel_addr + 0x00008000);
+    write_string_to_file(tmp, tagstmp);
+
+    //printf("pagesize...\n");
+    sprintf(tmp, "%s/%s", directory, basename(filename));
+    strcat(tmp, "-pagesize");
+    char pagesizetmp[200];
+    sprintf(pagesizetmp, "%d", header.page_size);
+    write_string_to_file(tmp, pagesizetmp);
+    
+    total_read += sizeof(header);
+    //printf("total read: %d\n", total_read);
+    total_read += read_padding(f, sizeof(header), pagesize);
+
+	int mtk_size_adjust = is_mtk ? -MTK_HEADER_SIZE : 0;
+	
+    sprintf(tmp, "%s/%s", directory, basename(filename));
+    strcat(tmp, "-zImage");
+    FILE *k = fopen(tmp, "wb");
+    byte* kernel = (byte*)malloc(header.kernel_size + mtk_size_adjust);
+    //printf("Reading kernel...\n");
+    maybe_skip_mtk_header(f, is_mtk);
+    fread(kernel, header.kernel_size + mtk_size_adjust, 1, f);
+    total_read += header.kernel_size;
+    fwrite(kernel, header.kernel_size + mtk_size_adjust, 1, k);
+    fclose(k);
+
+    //printf("total read: %d\n", header.kernel_size);
+    total_read += read_padding(f, header.kernel_size, pagesize);
+
+
+    byte* ramdisk = (byte*)malloc(header.ramdisk_size + mtk_size_adjust);
+    //printf("Reading ramdisk...\n");
+    maybe_skip_mtk_header(f, is_mtk);
+    fread(ramdisk, header.ramdisk_size + mtk_size_adjust, 1, f);
+    total_read += header.ramdisk_size;
+    sprintf(tmp, "%s/%s", directory, basename(filename));
+    if(ramdisk[0] == 0x02 && ramdisk[1]== 0x21)
+        strcat(tmp, "-ramdisk.lz4");
+    else
+        strcat(tmp, "-ramdisk.gz");
+    FILE *r = fopen(tmp, "wb");
+    fwrite(ramdisk, header.ramdisk_size + mtk_size_adjust, 1, r);
+    fclose(r);
+
+    total_read += read_padding(f, header.ramdisk_size, pagesize);
+
+    sprintf(tmp, "%s/%s", directory, basename(filename));
+    strcat(tmp, "-second");
+    FILE *s = fopen(tmp, "wb");
+    byte* second = (byte*)malloc(header.second_size + mtk_size_adjust);
+    //printf("Reading second...\n");
+    maybe_skip_mtk_header(f, is_mtk);
+    fread(second, header.second_size + mtk_size_adjust, 1, f);
+    total_read += header.second_size;
+    fwrite(second, header.second_size + mtk_size_adjust, 1, r);
+    fclose(s);
+
+    total_read += read_padding(f, header.second_size, pagesize);
+
+    sprintf(tmp, "%s/%s", directory, basename(filename));
+    strcat(tmp, "-dt");
+    FILE *d = fopen(tmp, "wb");
+    byte* dt = (byte*)malloc(header.dt_size + mtk_size_adjust);
+    //printf("Reading dt...\n");
+    maybe_skip_mtk_header(f, is_mtk);
+    fread(dt, header.dt_size + mtk_size_adjust, 1, f);
+    total_read += header.dt_size;
+    fwrite(dt, header.dt_size + mtk_size_adjust, 1, r);
+    fclose(d);
+    
+    fclose(f);
+    
+    //printf("Total Read: %d\n", total_read);
+    return 0;
+}

From 5ecf70c5d7d8e6d782b1ab4a8a254c829abb26c9 Mon Sep 17 00:00:00 2001
From: adi766 <adityakumarteli7846@gmail.com>
Date: Sat, 23 Sep 2017 07:48:04 +0000
Subject: [PATCH] Mediatek: Various Fixes

Signed-off-by: teja98 <tejachaitu96@gmail.com>
---
 init/init.cpp               |  2 +-
 libcutils/Android.mk        | 10 +++++++++-
 libcutils/fs_config.c       |  2 +-
 libcutils/mtk_audioCompat.c |  4 ++++
 libcutils/mtk_xlog.cpp      | 27 +++++++++++++++++++++++++++
 rootdir/init.rc             | 18 ++++++++++++++++++
 6 files changed, 60 insertions(+), 3 deletions(-)
 create mode 100644 libcutils/mtk_audioCompat.c
 create mode 100644 libcutils/mtk_xlog.cpp

diff --git a/init/init.cpp b/init/init.cpp
index 7d8f6ed84..8fa198ea3 100755
--- a/init/init.cpp
+++ b/init/init.cpp
@@ -555,7 +555,7 @@ static int charging_mode_booting(void) {
     }
 
     close(f);
-    return ('1' == cmb);
+    return ('8' == cmb);
 #endif
 }
 
diff --git a/libcutils/Android.mk b/libcutils/Android.mk
index 74b79448d..08d477418 100644
--- a/libcutils/Android.mk
+++ b/libcutils/Android.mk
@@ -102,6 +102,8 @@ LOCAL_SRC_FILES := $(libcutils_common_sources) \
         qtaguid.c \
         trace-dev.c \
         uevent.c \
+        mtk_xlog.cpp \
+        mtk_audioCompat.c
 
 LOCAL_SRC_FILES_arm += arch-arm/memset32.S
 LOCAL_SRC_FILES_arm64 += arch-arm64/android_memset.S
@@ -127,7 +129,13 @@ endif
 
 LOCAL_C_INCLUDES := $(libcutils_c_includes)
 LOCAL_STATIC_LIBRARIES := liblog
-LOCAL_CFLAGS += -Werror -Wall -Wextra -std=gnu90
+ifneq ($(ENABLE_CPUSETS),)
+LOCAL_CFLAGS += -DUSE_CPUSETS
+endif
+ifneq ($(ENABLE_SCHEDBOOST),)
+LOCAL_CFLAGS += -DUSE_SCHEDBOOST
+endif
+LOCAL_CFLAGS += -Wall -Wextra -std=gnu90
 LOCAL_CLANG := true
 LOCAL_SANITIZE := integer
 include $(BUILD_STATIC_LIBRARY)
diff --git a/libcutils/fs_config.c b/libcutils/fs_config.c
index 6c18bca6b..ba88ce897 100644
--- a/libcutils/fs_config.c
+++ b/libcutils/fs_config.c
@@ -146,7 +146,7 @@ static const struct fs_path_config android_files[] = {
     { 00700, AID_SYSTEM,    AID_SHELL,     CAP_MASK_LONG(CAP_BLOCK_SUSPEND), "system/bin/inputflinger" },
 
     /* Support FIFO scheduling mode in SurfaceFlinger. */
-    { 00755, AID_SYSTEM,    AID_GRAPHICS,     CAP_MASK_LONG(CAP_SYS_NICE), "system/bin/surfaceflinger" },
+    //{ 00755, AID_SYSTEM,    AID_GRAPHICS,     CAP_MASK_LONG(CAP_SYS_NICE), "system/bin/surfaceflinger" },
 
     { 00750, AID_ROOT,      AID_ROOT,      0, "system/bin/uncrypt" },
     { 00750, AID_ROOT,      AID_ROOT,      0, "system/bin/install-recovery.sh" },
diff --git a/libcutils/mtk_audioCompat.c b/libcutils/mtk_audioCompat.c
new file mode 100644
index 000000000..7b00e646d
--- /dev/null
+++ b/libcutils/mtk_audioCompat.c
@@ -0,0 +1,4 @@
+int get_capture_position(void)
+{
+    return 0;
+}
diff --git a/libcutils/mtk_xlog.cpp b/libcutils/mtk_xlog.cpp
new file mode 100644
index 000000000..48abe313c
--- /dev/null
+++ b/libcutils/mtk_xlog.cpp
@@ -0,0 +1,27 @@
+#include <cutils/log.h>
+
+extern "C" {
+	struct xlog_record {
+		const char *tag_str;
+		const char *fmt_str;
+		int prio;
+	};
+
+	static void init(void) __attribute__ ((constructor));
+
+	void init(void){}
+
+	int __xlog_buf_printf(int bufid, const struct xlog_record *rec, ...)
+	{
+	  va_list args;
+	  va_start(args, rec);
+	  LOG_PRI_VA(rec->prio, rec->tag_str, rec->fmt_str, args);
+	  va_end(args);
+
+	  return 0;
+	}
+
+	void dl_unregister_notify_function(void){}
+
+	void dl_register_notify_function(int (*load_notify_function) (const char *name, uintptr_t address, uintptr_t size), int(*unload_notify_function) (const char *name, uintptr_t address)){}
+}
diff --git a/rootdir/init.rc b/rootdir/init.rc
index 36a98d555..10f77f640 100644
--- a/rootdir/init.rc
+++ b/rootdir/init.rc
@@ -216,6 +216,7 @@ on init
 
     # Create location for fs_mgr to store abbreviated output from filesystem
     # checker programs.
+
     mkdir /dev/fscklogs 0770 root system
 
     # pstore/ramoops previous console log
@@ -658,6 +659,23 @@ service healthd /sbin/healthd
     seclabel u:r:healthd:s0
     group root system wakelock
 
+service surfaceflinger /system/bin/surfaceflinger
+    class core
+    user root
+    group graphics drmrpc
+    onrestart restart zygote
+
+service drm /system/bin/drmserver
+    class main
+    user drm
+    group drm system inet drmrpc
+
+service media /system/bin/mediaserver
+    class main
+    user root
+    group audio camera inet net_bt net_bt_admin net_bw_acct drmrpc mediadrm qcom_diag
+    ioprio rt 4
+
 service console /system/bin/sh
     class core
     console

From a13d65cd9814e8c52aa534066ceadbe1268286f9 Mon Sep 17 00:00:00 2001
From: adi766 <adityakumarteli7846@gmail.com>
Date: Sat, 23 Sep 2017 07:50:12 +0000
Subject: [PATCH] Mediatek: Prevent log spamming of audio.

---
 liblog/logger_write.c | 20 ++++++++++++++++++++
 1 file changed, 20 insertions(+)

diff --git a/liblog/logger_write.c b/liblog/logger_write.c
index c7b5a8415..aa85dd8c3 100644
--- a/liblog/logger_write.c
+++ b/liblog/logger_write.c
@@ -394,6 +394,26 @@ LIBLOG_ABI_PUBLIC int __android_log_buf_write(int bufID, int prio,
     if (!tag)
         tag = "";
 
+    // MediaTek: Prevent log spamming of audio.
+    if (!strcmp(tag, "AudioMTKFilterManager") ||
+        !strcmp(tag, "AudioMTKFilter") ||
+        !strcmp(tag, "AudioMTKStreamOut") ||
+        !strcmp(tag, "AudioVPWStreamIn") ||
+	!strcmp(tag, "AudioDigitalControl") ||
+        !strcmp(tag, "AudioLoopbackController") ||
+	!strcmp(tag, "AudioMTKVolumeController") ||
+        !strcmp(tag, "AudioDigitalControl") ||
+        !strcmp(tag, "AudioAnalogControl") ||
+        !strcmp(tag, "AudioAfeReg") ||
+        !strcmp(tag, "AudioAnalogReg") ||
+        !strcmp(tag, "AudioPlatformDevice") ||
+        !strcmp(tag, "AudioMachineDevice") ||
+        !strcmp(tag, "MtkAudioLoud") ||
+        !strcmp(tag, "LoopbackManager") ||
+        !strcmp(tag, "AudioInterConnection")) {
+             return 0;
+    }
+
     /* XXX: This needs to go! */
     if ((bufID != LOG_ID_RADIO) &&
          (!strcmp(tag, "HTC_RIL") ||

From 0c7462a7eab762b34ecd01bb08728fc0cac4b0af Mon Sep 17 00:00:00 2001
From: adi766 <adityakumarteli7846@gmail.com>
Date: Sat, 23 Sep 2017 07:52:29 +0000
Subject: [PATCH] Hide warning in cutils/trace.h

---
 include/cutils/trace.h | 4 ++--
 libcutils/trace-dev.c  | 6 ++++++
 libcutils/trace-host.c | 1 +
 3 files changed, 9 insertions(+), 2 deletions(-)

diff --git a/include/cutils/trace.h b/include/cutils/trace.h
index 19313afbb..0f0041720 100644
--- a/include/cutils/trace.h
+++ b/include/cutils/trace.h
@@ -189,8 +189,8 @@ static inline void atrace_begin(uint64_t tag, const char* name)
 static inline void atrace_end(uint64_t tag)
 {
     if (CC_UNLIKELY(atrace_is_tag_enabled(tag))) {
-        char c = 'E';
-        write(atrace_marker_fd, &c, 1);
+        void atrace_end_body();
+        atrace_end_body();
     }
 }
 
diff --git a/libcutils/trace-dev.c b/libcutils/trace-dev.c
index 778e4f03b..099ab458c 100644
--- a/libcutils/trace-dev.c
+++ b/libcutils/trace-dev.c
@@ -196,6 +196,12 @@ void atrace_begin_body(const char* name)
     write(atrace_marker_fd, buf, len);
 }
 
+void atrace_end_body()
+{
+    char c = 'E';
+    write(atrace_marker_fd, &c, 1);
+}
+
 #define WRITE_MSG(format_begin, format_end, pid, name, value) { \
     char buf[ATRACE_MESSAGE_LENGTH]; \
     int len = snprintf(buf, sizeof(buf), format_begin "%s" format_end, pid, \
diff --git a/libcutils/trace-host.c b/libcutils/trace-host.c
index 6478e3e52..05842cd7d 100644
--- a/libcutils/trace-host.c
+++ b/libcutils/trace-host.c
@@ -29,6 +29,7 @@ void atrace_set_tracing_enabled(bool enabled __unused) { }
 void atrace_update_tags() { }
 void atrace_setup() { }
 void atrace_begin_body(const char* name __unused) { }
+void atrace_end_body() { }
 void atrace_async_begin_body(const char* name __unused, int32_t cookie __unused) { }
 void atrace_async_end_body(const char* name __unused, int32_t cookie __unused) { }
 void atrace_int_body(const char* name __unused, int32_t value __unused) { }

From 57f486627def6bd9c64aab235528b26030b21547 Mon Sep 17 00:00:00 2001
From: adi766 <adityakumarteli7846@gmail.com>
Date: Sat, 23 Sep 2017 08:04:34 +0000
Subject: [PATCH] Correction for old kernel & Remove space

---
 init/Android.mk       | 4 ++++
 init/init.cpp         | 4 ++++
 liblog/logger_write.c | 4 ++--
 3 files changed, 10 insertions(+), 2 deletions(-)

diff --git a/init/Android.mk b/init/Android.mk
index 0f5fe1ce6..7a68b004b 100644
--- a/init/Android.mk
+++ b/init/Android.mk
@@ -20,6 +20,10 @@ ifneq ($(TARGET_INIT_CONSOLE_TIMEOUT),)
 init_options += -DCONSOLE_TIMEOUT_SEC=$(TARGET_INIT_CONSOLE_TIMEOUT)
 endif
 
+ifeq ($(OLD_KERNEL),true)
+init_options += -Dold_kernel=\"$(TARGET_BOARD_PLATFORM)\"
+endif
+
 init_cflags += \
     $(init_options) \
     -Wall -Wextra \
diff --git a/init/init.cpp b/init/init.cpp
index 8fa198ea3..ee5f03db3 100755
--- a/init/init.cpp
+++ b/init/init.cpp
@@ -366,7 +366,11 @@ static void export_kernel_boot_props() {
         { "ro.boot.mode",       "ro.bootmode",   "unknown", },
         { "ro.boot.baseband",   "ro.baseband",   "unknown", },
         { "ro.boot.bootloader", "ro.bootloader", "unknown", },
+#ifndef old_kernel
         { "ro.boot.hardware",   "ro.hardware",   "unknown", },
+#else
+        { "ro.boot.hardware",   "ro.hardware",   old_kernel, },
+#endif
 #ifndef IGNORE_RO_BOOT_REVISION
         { "ro.boot.revision",   "ro.revision",   "0", },
 #endif
diff --git a/liblog/logger_write.c b/liblog/logger_write.c
index aa85dd8c3..c65a0cf1a 100644
--- a/liblog/logger_write.c
+++ b/liblog/logger_write.c
@@ -399,9 +399,9 @@ LIBLOG_ABI_PUBLIC int __android_log_buf_write(int bufID, int prio,
         !strcmp(tag, "AudioMTKFilter") ||
         !strcmp(tag, "AudioMTKStreamOut") ||
         !strcmp(tag, "AudioVPWStreamIn") ||
-	!strcmp(tag, "AudioDigitalControl") ||
+        !strcmp(tag, "AudioDigitalControl") ||
         !strcmp(tag, "AudioLoopbackController") ||
-	!strcmp(tag, "AudioMTKVolumeController") ||
+        !strcmp(tag, "AudioMTKVolumeController") ||
         !strcmp(tag, "AudioDigitalControl") ||
         !strcmp(tag, "AudioAnalogControl") ||
         !strcmp(tag, "AudioAfeReg") ||

From a5c5e16874a1f79e402a23a14332eec743bfcdfb Mon Sep 17 00:00:00 2001
From: adi766 <adityakumarteli7846@gmail.com>
Date: Sat, 23 Sep 2017 23:27:29 +0000
Subject: [PATCH] Read MediaTek Serial number

---
 init/init.cpp | 35 +++++++++++++++++++++++++++++++++++
 1 file changed, 35 insertions(+)

diff --git a/init/init.cpp b/init/init.cpp
index ee5f03db3..0b3a45ecf 100755
--- a/init/init.cpp
+++ b/init/init.cpp
@@ -323,6 +323,37 @@ static int console_init_action(const std::vector<std::string>& args)
     return 0;
 }
 
+#ifdef MTK_HARDWARE
+static int read_serialno()
+{
+    int fd;
+    char serialno[32];
+    size_t s;
+
+    fd = open("/sys/sys_info/serial_number", O_RDWR);
+    if (fd < 0) {
+        NOTICE("fail to open: %s\n", "/sys/sys_info/serial_number");
+        return 0;
+    }
+    s = read(fd, serialno, sizeof(char)*32);
+
+    serialno[s-1] = '\0';
+
+    close(fd);
+
+    if (s <= 0) {
+	    NOTICE("could not read serial number sys file\n");
+	    return 0;
+	}
+
+    NOTICE("serial number=%s\n",serialno);
+
+    property_set("ro.boot.serialno", serialno);
+
+    return 1;
+}
+#endif
+
 static void import_kernel_nv(const std::string& key, const std::string& value, bool for_emulator) {
     if (key.empty()) return;
 
@@ -421,6 +452,10 @@ static void process_kernel_cmdline() {
     // as properties.
     import_kernel_cmdline(false, import_kernel_nv);
     if (qemu[0]) import_kernel_cmdline(true, import_kernel_nv);
+
+#ifdef MTK_HARDWARE
+    read_serialno();
+#endif
 }
 
 static int property_enable_triggers_action(const std::vector<std::string>& args)